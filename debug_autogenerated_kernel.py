#!/usr/bin/env python3
"""
debug_autogenerated_kernel.py - Prepare an autogenerated CUDA kernel file for debugging.

OVERVIEW
--------
Autogenerated CUDA kernel files (e.g., in src_lib/autogenerated_kernels/) contain GPU kernels
that are registered at library load time. When debugging these kernels, you may want to modify
and recompile a single kernel without regenerating the entire file.

This script automates the kernel debugging workflow:

  1. Takes an autogenerated .cu file as input
  2. Renames all __global__ kernel functions by adding a 'debug_' prefix
  3. Sets 'debug = true' (was 'debug = false') in the kernel registration code
  4. Writes the result to DIRNAME/debug.cu

WHY THIS WORKS
--------------
- The Makefile compiles debug.cu if it exists (it is not deleted by 'make clean').
- When a kernel is registered with debug=true, it takes precedence over the same kernel
  registered with debug=false, allowing the debug version to override the original.
- By renaming kernels to debug_*, we avoid linker conflicts with the original kernels.

USAGE
-----
    ./debug_autogenerated-kernel.py DIRNAME/BASENAME.cu

Example:
    ./debug_autogenerated-kernel.py src_lib/autogenerated_kernels/dd_fp32_norb_nolag_s8.cu

This creates src_lib/autogenerated_kernels/debug.cu with:
  - All kernel names prefixed with 'debug_'
  - All 'debug = false;' lines changed to 'debug = true;'

WORKFLOW
--------
1. Run this script on the autogenerated kernel file you want to debug
2. Edit debug.cu to make your changes (add printf, modify logic, etc.)
3. Run 'make' to rebuild
4. Test your changes
5. When done debugging, delete debug.cu

If debug.cu already exists, it will be renamed to debug_0.cu (or debug_1.cu, etc.)
to avoid accidentally overwriting your work.
"""

import sys
import os
import re


def find_kernel_names(content):
    """
    Find all __global__ kernel function names in the CUDA source.
    
    Matches declarations like:
        __global__ void kernel_name(...)
        __global__ void __launch_bounds__(M,N) kernel_name(...)
    
    Returns a list of kernel names.
    """
    # Pattern explanation:
    # - __global__\s+void\s+ : matches "__global__ void " with flexible whitespace
    # - (?:__launch_bounds__\s*\([^)]*\)\s*)? : optionally matches __launch_bounds__(...) 
    # - (\w+) : captures the kernel name (one or more word characters)
    # - \s*\( : matches optional whitespace followed by opening parenthesis
    pattern = r'__global__\s+void\s+(?:__launch_bounds__\s*\([^)]*\)\s*)?(\w+)\s*\('
    
    matches = re.findall(pattern, content)
    # Remove duplicates while preserving order
    seen = set()
    unique = []
    for name in matches:
        if name not in seen:
            seen.add(name)
            unique.append(name)
    return unique


def rename_kernels(content, kernel_names):
    """
    Rename all kernel functions by adding 'debug_' prefix.
    
    This renames both the declaration and all references to the kernel.
    """
    for name in kernel_names:
        # Use word boundaries to avoid partial matches
        # (e.g., don't match 'my_kernel_helper' when renaming 'kernel')
        pattern = r'\b' + re.escape(name) + r'\b'
        new_name = f'debug_{name}'
        content = re.sub(pattern, new_name, content)
    return content


def enable_debug_flag(content):
    """
    Replace 'debug = false;' with 'debug = true;'.
    
    This enables the debug flag in kernel registration code, which causes
    the debug kernels to take precedence over the original kernels.
    """
    # Match various whitespace patterns around the assignment
    pattern = r'\bdebug\s*=\s*false\s*;'
    replacement = 'debug = true;'
    return re.sub(pattern, replacement, content)


def get_backup_filename(dirname):
    """
    Find a unique backup filename for an existing debug.cu file.
    
    Returns debug_0.cu, debug_1.cu, etc. - whichever doesn't exist yet.
    """
    i = 0
    while True:
        backup = os.path.join(dirname, f'debug_{i}.cu')
        if not os.path.exists(backup):
            return backup
        i += 1


def main():
    if len(sys.argv) != 2:
        print(f"Usage: {sys.argv[0]} DIRNAME/BASENAME.cu", file=sys.stderr)
        print(f"Example: {sys.argv[0]} src_lib/autogenerated_kernels/dd_fp32_norb_nolag_s8.cu", file=sys.stderr)
        sys.exit(1)
    
    input_path = sys.argv[1]
    
    # Validate input file
    if not os.path.isfile(input_path):
        print(f"Error: Input file not found: {input_path}", file=sys.stderr)
        sys.exit(1)
    
    if not input_path.endswith('.cu'):
        print(f"Warning: Input file does not have .cu extension: {input_path}", file=sys.stderr)
    
    dirname = os.path.dirname(input_path) or '.'
    basename = os.path.basename(input_path)
    output_path = os.path.join(dirname, 'debug.cu')
    
    print(f"Input file: {input_path}")
    print(f"Output file: {output_path}")
    print()
    
    # Read input file
    print(f"Reading {input_path}...")
    with open(input_path, 'r') as f:
        content = f.read()
    
    # Find kernel names
    kernel_names = find_kernel_names(content)
    if not kernel_names:
        print("Warning: No __global__ kernel declarations found!", file=sys.stderr)
    else:
        print(f"Found {len(kernel_names)} kernel(s):")
        for name in kernel_names:
            print(f"  {name} -> debug_{name}")
    print()
    
    # Rename kernels
    print("Renaming kernels...")
    content = rename_kernels(content, kernel_names)
    
    # Enable debug flag
    print("Setting debug = true...")
    debug_count_before = len(re.findall(r'\bdebug\s*=\s*false\s*;', content))
    content = enable_debug_flag(content)
    debug_count_after = len(re.findall(r'\bdebug\s*=\s*true\s*;', content))
    print(f"  Replaced {debug_count_before} occurrence(s) of 'debug = false;'")
    print()
    
    # Handle existing debug.cu
    if os.path.exists(output_path):
        backup_path = get_backup_filename(dirname)
        print(f"Existing debug.cu found, renaming to {os.path.basename(backup_path)}")
        os.rename(output_path, backup_path)
    
    # Write output file
    print(f"Writing {output_path}...")
    with open(output_path, 'w') as f:
        f.write(content)
    
    print()
    print("Done! Next steps:")
    print(f"  1. Edit {output_path} to add your debugging code")
    print("  2. Run 'make' to rebuild")
    print("  3. Test your changes")
    print(f"  4. Delete {output_path} when done debugging")


if __name__ == '__main__':
    main()


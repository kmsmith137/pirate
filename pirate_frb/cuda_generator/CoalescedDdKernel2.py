import os
import re
import numpy as np

from . import utils

from .Dtype import Dtype
from .Kernel import Kernel
from .Ringbuf import Ringbuf
from .FrequencySubbands import FrequencySubbands
from .Dedisperser import Dedisperser, MultiDedisperser
from .PeakFinder import PeakFinder


class CoalescedDdKernel2:
    def __init__(self, dtype, dd_rank, frequency_subbands, Wmax, Dcore, Dout, Tinner):
        """
        Coalesced Dedisperser + PeakFinder.
        We currently assume apply_input_residual_lags == input_is_ringbuf == True.
        """

        self.dtype = dtype = Dtype(dtype)
        self.frequency_subbands = frequency_subbands                                            
        self.dd_rank = dd_rank
        self.Tinner = Tinner
        self.Dcore = Dcore
        self.Dout = Dout
        self.Wmax = Wmax

        self.dt32 = dtype.simd32
        self.SW = dtype.simd_width
        self.rb = Ringbuf(self.dt32)  # simd dtype, not scalar dtype

        self.dd = Dedisperser(
            dtype = dtype,
            rank = dd_rank,
            apply_input_residual_lags = True,
            input_is_ringbuf = True,
            output_is_ringbuf = False,
            nspec = 1,
            ringbuf = self.rb   # note that ringbuf is shared between Dedisperser and PeakFinder
        )

        self.pf = PeakFinder(
            dtype = dtype,
            frequency_subbands = frequency_subbands,
            Wmax = Wmax,
            Dcore = Dcore,
            Dout = Dout,
            Tinner = Tinner,
            ringbuf = self.rb   # note that ringbuf is shared between Dedisperser and PeakFinder
        )

        # These restrictions may be relaxed in the future.
        assert self.dd.two_stage
        assert frequency_subbands.pf_rank == self.dd.rank1
        
        # From Dedisperser
        self.warps_per_threadblock = self.dd.warps_per_threadblock
        self.shmem_nbytes = self.dd.shmem_nbytes
        self.nt_per_segment = self.dd.nt_per_segment

        # From PeakFinder
        self.P = self.pf.P
        self.M = self.pf.M
        self.Minner = self.pf.Minner
        self.pf_rank = self.pf.pf_rank
        self.weight_layout = self.pf.weight_layout

        # Typical kernel name: cdd2_fp32_r7_f11_f6_f3_f1_W16_Dcore8_Dout16_Tinner1
        self.kernel_name = f'cdd2_{dtype.fname}_r{dd_rank}_{frequency_subbands.fstr}_W{Wmax}_Dcore{Dcore}_Dout{Dout}_Tinner{Tinner}'
        self.kernel_basename = self.kernel_name + '.cu'

        # For testing: if a peak-finding kernel is precompiled, we also precompile unit tests
        # for the associated sub-kernels. (In the case of the dedispersion sub-kernel, we precompile
        # the MultiDedisperser that contains the sub-kernel.)

        mdd = MultiDedisperser(
            dtype = self.dd.dtype,
            apply_input_residual_lags = self.dd.apply_input_residual_lags, 
            input_is_ringbuf = self.dd.input_is_ringbuf, 
            output_is_ringbuf = self.dd.output_is_ringbuf, 
            nspec = self.dd.nspec
        )

        self.all_kernel_basenames = [ self.kernel_basename, mdd.kernel_basename ] + self.pf.all_kernel_basenames


    def emit_kernel(self, k):
        """Emits the complete kernel, including prologue, body, and registry registration."""
        
        assert isinstance(k, Kernel)

        # ---------------  Prologue  ---------------
        
        k.emit('#include "../../include/pirate/CoalescedDdKernel2.hpp"')
        k.emit('#include "../../include/pirate/FrequencySubbands.hpp"')
        k.emit('#include "../../include/pirate/inlines.hpp"')
        k.emit('#include <ksgpu/device_fp16.hpp>   // f16_perm(), f16_align()')
        k.emit()
        k.emit('using namespace std;')
        k.emit('using namespace ksgpu;')
        k.emit()
        k.emit('namespace pirate {')
        k.emit('#if 0')
        k.emit('}  // editor auto-indent')
        k.emit('#endif')
        k.emit()

        # ---------------  CUDA kernel  ---------------
        
        # launch_bounds
        lb_warps = self.warps_per_threadblock
        lb_blocks = utils.xdiv(16, lb_warps)

        k.emit(f'// Autogenerated by pirate_frb.cuda_generator')
        k.emit()
        k.emit(f'// Launch with {{ 32, {self.warps_per_threadblock} }} threads/warp')
        k.emit(f'// Launch with {{ Namb, Nbeams }} threadblocks')
        k.emit()

        k.emit(f'__global__ void __launch_bounds__({32 * lb_warps}, {lb_blocks})')
        k.emit(f'{self.kernel_name}(')
        k.emit(f'    void *grb_base_, uint *grb_quads_, long grb_frame0,    // dedisperser input (ring buffer)')
        k.emit(f'    void *out_max_, uint *out_argmax, const void *wt_,     // peak-finder output')
        k.emit(f'    void *pstate_, int ntime,                              // shared between dedisperser and peak-finder')
        k.emit(f'    ulong nt_cumul, bool is_downsampled_tree,              // dedisperser')
        k.emit(f'    uint ndm_out_per_wt, uint nt_in_per_wt)                // peak-finder')
        k.emit('{')
        k.emit(f'constexpr int M = {self.M};')
        k.emit(f'constexpr int Dout = {self.Dout};')
        k.emit(f'constexpr int Dcore = {self.Dcore};')
        k.emit(f'constexpr int Minner = {self.Minner};')
        k.emit(f'constexpr int Tinner = {self.Tinner};')
        k.emit(f'constexpr int wt_touter_stride32 = {utils.xdiv(self.pf.wt_touter_byte_stride,4)};')
        k.emit()

        if self.Wmax > 1:
            k.emit(f'{self.dt32} pf_a = {self.dtype.from_float("0.5f")};')
            k.emit()

        self.dd._apply_inbuf_offsets(k)    # operates on grb* pointers, since self.dd.input_is_ringbuf == True

        # No call to self.dd._apply_outbuf_offsets() in coalesced kernel,
        # Instead, call self._apply_pfout_offsets(), which operates on out_max, out_argmax, wt pointers.
        self._apply_pfout_offsets(k)

        # No-ops if self.two_stage == False.
        self.dd._init_srb(k)

        # PfWeightReader.top() is currently a placeholder that does not emit any code.
        self.pf.pf_weight_reader.top(k, 'wt')

        # Save splice, for code to load pstate.
        # This code must be emitted near the end, after the ring buffer layout is finalized.
        # Note that pstate is managed by the dedispersion kernel.
        k_pstate = k.splice()

        k.emit(f'for (int itime = 0; itime < ntime; itime += {self.nt_per_segment}) {{')

        self.dd._load_input_data(k)              # behaves differently, depending on self.input_is_ringbuf
        self.dd._apply_input_residual_lags(k)    # no-ops if (self.apply_input_residual_lags) is False

        # The 'return_early=True' arg means that the caller is responsible for emitting the following code.
        # (Assumes that self.dd.rank1 == self.pf_rank, which is assert-ed at the beginning of the kernel.)
        #
        #   for i in range(self.pf_rank):
        #       self.dd._dedispersion_pass(k,i)

        self.dd._two_stage_dedispersion_core(k, return_early=True)

        k.emit()
        k.emit("// Here is the point in the code where we start emitting peak-finding logic.")
        k.emit("// The peak-finding logic is interleaved with the later stages of dedispersion.")
        k.emit("// FIXME I'm a bit worried that this way of doing it will lead to register pressure")
        k.emit("// I made a note to revisit this later.")
        k.emit()

        sc = self.frequency_subbands.subband_counts
        mcurr = 0
        
        k.emit()
        k.emit(f'// Create {sc[0]} peak-finding output(s) at pf_level 0. I decided to treat this as a')
        k.emit(f'// special case, because the bands are "unstaggered" (see comments in FrequencySubbands.cu')
        k.emit()

        for pfs in range(sc[0]):
            self.frequency_subbands.check_m(mcurr, pfs, pfs+1, 0)
            self.pf.process_pf_input(k, f'dd{pfs}', mcurr)
            mcurr += 1

        for pf_level in range(1, self.pf_rank+1):
            k.emit()
            k.emit(f'// Create {sc[pf_level]} "staggered" peak-finding output(s) at pf_level {pf_level}.')
            k.emit(f'// Step 1: generate odd values of "pfs", and save to registers.')
            k.emit()

            for pfs in range(1, sc[pf_level], 2):
                for pfd2 in range(2**(pf_level-1)):
                    # Generate (pfs,2*pfd2) and (pfs,2*pfd2+1)
                    isrc = pfs * 2**(pf_level-1) + utils.bit_reverse(pfd2, pf_level-1)
                    src0 = f'dd{isrc}'
                    src1 = f'dd{isrc + 2**(pf_level-1)}'
                    dst0 = f'pfodd_l{pf_level}_s{pfs}_d{2*pfd2}'
                    dst1 = f'pfodd_l{pf_level}_s{pfs}_d{2*pfd2+1}'
                    lag = pfd2

                    k.emit(f'// Sum with lag=({lag},{lag+1}): src=({src0},{src1}), dst=({dst0,dst1})')
                    tmp0, tmp1 = self.dd._advance2(k, src0, lag)   # behaves differently for float32, float16

                    k.emit(f'{self.dt32} {dst0} = {tmp1} + {src1};')
                    k.emit(f'{self.dt32} {dst1} = {tmp0} + {src1};')


            k.emit()
            k.emit(f'// Create {sc[pf_level]} "staggered" peak-finding output(s) at pf_level {pf_level}.')
            k.emit(f'// Step 2: do one dedispersion stage.')
            k.emit()

            self.dd._dedispersion_pass(k, pf_level-1)
            
            k.emit()
            k.emit(f'// Create {sc[pf_level]} "staggered" peak-finding output(s) at pf_level {pf_level}.')
            k.emit(f'// Step 3: generate even values of "pfs", with peak-finding logic emitted incrementally')
            k.emit()

            for pfs in range(sc[pf_level]):
                for pfd in range(2**pf_level):
                    # The peak-finding output is already held in a register, but the logic for generating
                    # the register name depends on whether 'pfs' is even or odd. If 'pfs' is odd, then it
                    # was generated in "step 1" above. If 'pfs' is even, then it was generated in step 2.

                    if pfs % 2:
                        name = f'pfodd_l{pf_level}_s{pfs}_d{pfd}'
                    else:
                        isrc = (pfs//2) * 2**(pf_level) + utils.bit_reverse(pfd, pf_level)
                        name = f'dd{isrc}'

                    self.frequency_subbands.check_m(mcurr, pfs * 2**(pf_level-1), (pfs+2) * 2**(pf_level-1), pfd)
                    self.pf.process_pf_input(k, name, mcurr)
                    mcurr += 1

        assert mcurr == self.frequency_subbands.M

        # No call to self.dd._save_output_data() in coalesced kernel.
        # Instead, call self.pf.process_pf_outputs()
        self.pf.pf_output.apply_outer(k, 'out_max', 'out_argmax', 'itime', 'ntime')
        self.pf.pf_weight_reader.bottom(k, 'itime', 'nt_in_per_wt')

        self.dd._advance_rrb(k)
        self.dd._advance_srb(k)      # no-ops if (self.two_stage) is False
        self.dd._advance_inbuf(k)    # behaves differently, depending on self.input_is_ringbuf
        # No call to self.dd._advance_outbuf() in coalesced kernel.
        
        k.emit('}   // outer time loop')

        # Now that 'self.rrb' has been finalized, we can sort out the pstate.
        self.dd._lay_out_pstate(k_pstate)    # initializes some members, including self.dd.pstate32_per_small_tree
        self.dd._load_pstate(k_pstate)
        self.dd._save_pstate(k)

        k.emit('    // placeholder')
        k.emit('}  // end of cuda kernel')
        

    def emit_registration(self, k):
        fs = self.frequency_subbands
        wl = self.weight_layout
        sb_counts = ', '.join(str(int(x)) for x in fs.subband_counts)
        m_to_f = ', '.join(str(int(f)) for f,d in fs.m_to_fd)
        m_to_d = ', '.join(str(int(d)) for f,d in fs.m_to_fd)
        f_to_ilo = ', '.join(str(int(ilo)) for ilo,ihi in fs.f_to_irange)
        f_to_ihi = ', '.join(str(int(ihi)) for ilo,ihi in fs.f_to_irange)

        k.emit('\n// Boilerplate to register the kernel when the library is loaded.')
        k.emit('namespace {')
        k.emit('struct register_hack {')
        k.emit('register_hack() {')
        k.emit('CoalescedDdKernel2::RegistryKey k;')
        k.emit(f'k.dtype = ksgpu::Dtype::native<{self.dtype.scalar}>();')
        k.emit(f'k.dd_rank = {self.dd_rank};')
        k.emit(f'k.subband_counts = {{ {sb_counts} }};')
        k.emit(f'k.Tinner = {self.Tinner};')
        k.emit(f'k.Dout = {self.Dout};')
        k.emit(f'k.Wmax = {self.Wmax};')
        k.emit()
        k.emit('CoalescedDdKernel2::RegistryValue v;')
        k.emit(f'v.cuda_kernel = {self.kernel_name};')
        k.emit(f'v.Dcore = {self.Dcore};')
        k.emit(f'v.shmem_nbytes = {self.shmem_nbytes};')
        k.emit(f'v.warps_per_threadblock = {self.warps_per_threadblock};')
        k.emit(f'v.pstate32_per_small_tree = {self.dd.pstate32_per_small_tree};')
        k.emit(f'v.nt_per_segment = {self.nt_per_segment};')
        k.emit()
        k.emit(f'v.pf_weight_layout.dtype = ksgpu::Dtype::native<{self.dtype.scalar}>();')
        k.emit(f'v.pf_weight_layout.F = {fs.F};')
        k.emit(f'v.pf_weight_layout.P = {self.P};')
        k.emit(f'v.pf_weight_layout.Pouter = {wl.Pouter};')
        k.emit(f'v.pf_weight_layout.Pinner = {wl.Pinner};')
        k.emit(f'v.pf_weight_layout.Tinner = {self.Tinner};')
        k.emit(f'v.pf_weight_layout.touter_byte_stride = {wl.touter_byte_stride};')
        k.emit(f'v.pf_weight_layout.validate();  // throws an exception if anything is wrong')
        k.emit()
        k.emit('// Checks consistency of python/C++ FrequencySubbands')
        k.emit(f'FrequencySubbands fs({{ {sb_counts} }});')
        k.emit(f'xassert_eq(fs.F, {fs.F});')
        k.emit(f'xassert_eq(fs.M, {fs.M});')
        k.emit(f'xassert(vec_equal(fs.m_to_f, {{ {m_to_f} }}));')
        k.emit(f'xassert(vec_equal(fs.m_to_d, {{ {m_to_d} }}));')
        k.emit(f'xassert(vec_equal(fs.f_to_ilo, {{ {f_to_ilo} }}));')
        k.emit(f'xassert(vec_equal(fs.f_to_ihi, {{ {f_to_ihi} }}));')
        k.emit()
        k.emit('bool debug = false;')
        k.emit('CoalescedDdKernel2::registry().add(k, v, debug);')
        k.emit('} // register_hack constructor')
        k.emit('}; // struct register_hack')
        k.emit('register_hack hack;')
        k.emit('} // anonymous namespace')
        k.emit()
        k.emit('}   // namespace pirate')


    @classmethod
    def _idiv(cls, var, n):
        """Helper for _apply_pfout_offsets()."""
        return f'({var} >> {utils.integer_log2(n)})' if (n != 1) else var


    def _apply_pfout_offsets(self, k):
        dt32, SW, Dout = self.dt32, self.dtype.simd_width, self.Dout

        k.emit(f'// CoalescedDdKernel2._apply_outbuf_offsets() starts here.')
        k.emit(f"// Add per-warp pointer offsets (but not per-lane offsets) to 'out_max, 'out_argmax', and 'wt'.")
        k.emit(f'// This is tricky because the block/warp indices correspond to bit-reversed DMs, but the output')
        k.emit(f'// arrays are not bit-reversed.')
        k.emit()

        k.emit(f'const {dt32} *wt = (const {dt32} *) wt_;')
        k.emit(f'{dt32} *out_max = ({dt32} *) out_max_;')

        nt_out = self._idiv('ntime', Dout)
        nt_out32 = self._idiv('ntime', Dout*SW)

        k.emit(f'// FIXME could optimize out integer divisions')
        k.emit(f'uint ndm_out = blockDim.y * gridDim.x;')
        k.emit(f'uint lg2_ndm_out = __ffs(ndm_out) - 1;')
        k.emit(f'uint pf_beam = blockIdx.y;  // beam index is not bit-reversed')
        k.emit(f'uint dm_out_brev = threadIdx.y * gridDim.x + blockIdx.x;  // dm is bit-reversed')
        k.emit(f'uint dm_out = __brev(dm_out_brev) >> (32 - lg2_ndm_out);')
        k.emit(f'uint bd_out = pf_beam * ndm_out + dm_out;       // combined (beam,dm) index in out_max + out_argmax arrays')
        k.emit(f'uint bd_wt = bd_out / ndm_out_per_wt;           // combined (beam,dm) index in weight array')
        k.emit(f'uint Touter = ntime / (Tinner * nt_in_per_wt);  // see PfWeightLayout')
        k.emit()
        
        k.emit(f"// Add per-warp pointer offsets (but not per-lane offsets) to 'out_max, 'out_argmax', and 'wt'.")
        k.emit(f'out_max += bd_out * {nt_out32};                  // shape (beams, dm_out, ntime/Dout)')
        k.emit(f'out_argmax += bd_out * {nt_out};                 // shape (beams, dm_out, ntime/Dout)')
        k.emit(f'wt += bd_wt * Touter * wt_touter_stride32;     // shape (beams, ndm_wt, Touter,...)') 
        k.emit(f'// CoalescedDdKernel2._apply_outbuf_offsets() ends here.')
        k.emit()


    @classmethod
    def write_kernel(cls, filename):
        """Called from 'autogenerate_kernel.py' in the toplevel pirate directory."""
        
        basename = os.path.basename(filename)

        # Typical basename: cdd2_fp32_r7_f11_f6_f3_f1_W16_Dcore8_Dout16_Tinner1
        m = re.fullmatch(r'cdd2_(fp\d+)_r(\d+)_((?:f\d+_)*f\d+)_W(\d+)_Dcore(\d+)_Dout(\d+)_Tinner(\d+)\.cu', basename)
        if not m:
            raise RuntimeError(f"Couldn't match filename '{filename}'")
        
        dtype = Dtype(m.group(1))
        dd_rank = int(m.group(2))
        frequency_subbands = FrequencySubbands.from_fstr(m.group(3))
        Wmax, Dcore, Dout, Tinner = int(m.group(4)), int(m.group(5)), int(m.group(6)), int(m.group(7))

        cdd2_kernel = cls(dtype, dd_rank, frequency_subbands, Wmax, Dcore, Dout, Tinner)

        if cdd2_kernel.kernel_basename != basename:
            raise RuntimeError("CoalescedDdKernel2.write_kernel(): internal error: expected "
                               + f" {cdd2_kernel.kernel_basename=} and {basename=} to be equal")
                
        k = Kernel()
        cdd2_kernel.emit_kernel(k)
        cdd2_kernel.emit_registration(k)

        k.write_file(filename)
        
import os
import re
import numpy as np

from . import utils

from .Dtype import Dtype
from .Kernel import Kernel
from .Ringbuf import Ringbuf
from .FrequencySubbands import FrequencySubbands
from .Dedisperser import Dedisperser
from .PeakFinder import PeakFinder


class CoalescedDdKernel2:
    def __init__(self, dtype, dd_rank, frequency_subbands, W, Dcore, Dout, Tinner):
        """
        Coalesced Dedisperser + PeakFinder.
        We currently assume apply_input_residual_lags == input_is_ringbuf == True.
        """

        self.dtype = dtype = Dtype(dtype)
        self.frequency_subbands = frequency_subbands                                            
        self.dd_rank = dd_rank
        self.Tinner = Tinner
        self.Dcore = Dcore
        self.Dout = Dout
        self.W = W

        self.dt32 = dtype.simd32
        self.SW = dtype.simd_width
        self.rb = Ringbuf(self.dt32)  # simd dtype, not scalar dtype

        self.dd = Dedisperser(
            dtype = dtype,
            rank = dd_rank,
            apply_input_residual_lags = True,
            input_is_ringbuf = True,
            output_is_ringbuf = False,
            nspec = 1,
            ringbuf = self.rb   # note that ringbuf is shared between Dedisperser and PeakFinder
        )

        self.pf = PeakFinder(
            dtype = dtype,
            frequency_subbands = frequency_subbands,
            W = W,
            Dcore = Dcore,
            Dout = Dout,
            Tinner = Tinner,
            ringbuf = self.rb   # note that ringbuf is shared between Dedisperser and PeakFinder
        )

        # FIXME temporary cdd2 restrictions that will be relaxed later
        assert self.dd.two_stage
        assert dtype == Dtype('float')   # for now
        assert frequency_subbands.pf_rank == self.dd.rank1
        assert all(n==0 for n in frequency_subbands.subband_counts[:-1])
        
        # From Dedisperser
        self.warps_per_threadblock = self.dd.warps_per_threadblock
        self.shmem_nbytes = self.dd.shmem_nbytes
        self.pstate32_per_small_tree = 0  # self.dd.pstate32_per_small_tree
        self.nt_per_segment = self.dd.nt_per_segment

        # From PeakFinder
        self.P = self.pf.P
        self.M = self.pf.M
        self.weight_layout = self.pf.weight_layout

        # Typical kernel name: cdd2_fp32_r7_f11_f6_f3_f1_W16_Dcore8_Dout16_Tinner1
        self.kernel_name = f'cdd2_{dtype.fname}_r{dd_rank}_{frequency_subbands.fstr}_W{W}_Dcore{Dcore}_Dout{Dout}_Tinner{Tinner}'
        self.kernel_basename = self.kernel_name + '.cu'

        # For testing: if a peak-finding kernel is precompiled, we also precompile unit tests
        # for the associated sub-kernels.
        self.all_kernel_basenames = [ self.kernel_basename ] + self.pf.all_kernel_basenames


    def emit_global(self, k):
        assert isinstance(k, Kernel)

        # launch_bounds
        lb_warps = self.warps_per_threadblock
        lb_blocks = utils.xdiv(16, lb_warps)

        k.emit(f'// Autogenerated by pirate_frb.cuda_generator')
        k.emit()
        k.emit(f'// Launch with {{ 32, {self.warps_per_threadblock} }} threads/warp')
        k.emit(f'// Launch with {{ Namb, Nbeams }} threadblocks')
        k.emit()

        k.emit(f'__global__ void __launch_bounds__({32 * lb_warps}, {lb_blocks})')
        k.emit(f'{self.kernel_name}(')
        k.emit(f'    void *grb_base_, uint *grb_loc_, long grb_pos,         // dedisperser input (ring buffer)')
        k.emit(f'    void *out_max_, uint *out_argmax, const void *wt_,     // peak-finder output')
        k.emit(f'    void *pstate_, int ntime,                              // shared between dedisperser and peak-finder')
        k.emit(f'    ulong nt_cumul, bool is_downsampled_tree,              // dedisperser')
        k.emit(f'    uint ndm_out_per_wt, uint nt_in_per_wt)                // peak-finder')
        k.emit('{')
        k.emit('    // placeholder')
        k.emit('}  // end of cuda kernel')


    @classmethod
    def write_kernel(cls, filename):
        """Called from 'autogenerate_kernel.py' in the toplevel pirate directory."""
        
        basename = os.path.basename(filename)

        # Typical basename: cdd2_fp32_r7_f11_f6_f3_f1_W16_Dcore8_Dout16_Tinner1
        m = re.fullmatch(r'cdd2_(fp\d+)_r(\d+)_((?:f\d+_)*f\d+)_W(\d+)_Dcore(\d+)_Dout(\d+)_Tinner(\d+)\.cu', basename)
        if not m:
            raise RuntimeError(f"Couldn't match filename '{filename}'")
        
        dtype = Dtype(m.group(1))
        dd_rank = int(m.group(2))
        frequency_subbands = FrequencySubbands.from_fstr(m.group(3))
        W, Dcore, Dout, Tinner = int(m.group(4)), int(m.group(5)), int(m.group(6)), int(m.group(7))

        cdd2_kernel = cls(dtype, dd_rank, frequency_subbands, W, Dcore, Dout, Tinner)

        if cdd2_kernel.kernel_basename != basename:
            raise RuntimeError("CoalescedDdKernel2.write_kernel(): internal error: expected "
                               + f" {cdd2_kernel.kernel_basename=} and {basename=} to be equal")
                
        k = Kernel()
        cdd2_kernel.emit_global(k)

        k.write_file(filename)
        
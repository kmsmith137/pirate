import re

from .Kernel import Kernel
from .PeakFinder import PeakFinder, PeakFindingParams
from .Dedisperser import Dedisperser, DedisperserParams


def dtype_from_nbits(nbits):
    if nbits == 32:
        return 'float'
    if nbits == 16:
        return '__half'
    raise RuntimeError(f'Unrecognized dtype {dtype}')


def tf(x):
    """Needed since C++ uses lower-case true/false, and python uses upper-case True/False."""
    return "true" if x else "false"

    
def make_dd_file(nbits, apply_input_residual_lags, input_is_ringbuf, output_is_ringbuf, nspec):
    """Returns a Kernel object."""

    dtype = dtype_from_nbits(nbits)
    k = Kernel()
    
    k.emit('// Autogenerated by pirate_frb.cuda_generator')
    k.emit()
    k.emit('// For a high-level overview, see comments at the top of')
    k.emit('// pirate_frb/cuda_generator/Dedisperser.py')
    k.emit()
    k.emit('#include <cstdio>')
    k.emit('#include <cassert>')
    k.emit('#include <ksgpu/device_transposes.hpp>   // f16_perm(), f16_align()')
    k.emit('#include "../../include/pirate/DedispersionKernel.hpp"')
    k.emit()
    k.emit('namespace pirate {')
    k.emit()

    k_code = k.splice()

    for rank in range(1,9):
        pars = DedisperserParams(dtype, rank, apply_input_residual_lags, input_is_ringbuf, output_is_ringbuf, nspec)
        dd = Dedisperser(pars)
        
        dd.emit_global(k_code)
        k_code.emit()

        k_code.reset_tmp_vars()
        
        k.emit(f'// Boilerplate to register the rank={rank} kernel when the library is loaded.')
        k.emit('namespace {')
        k.emit(f'struct register_hack{rank} {{')
        k.emit(f'register_hack{rank}() {{')
        k.emit()
    
        k.emit('NewGpuDedispersionKernel::RegistryKey k;')
        k.emit(f'k.dtype = ksgpu::Dtype::native<{dtype}>();')
        k.emit(f'k.rank = {rank};')
        k.emit(f'k.input_is_ringbuf = {tf(input_is_ringbuf)};')
        k.emit(f'k.output_is_ringbuf = {tf(output_is_ringbuf)};')
        k.emit(f'k.apply_input_residual_lags = {tf(apply_input_residual_lags)};')
        k.emit()
        
        k.emit('NewGpuDedispersionKernel::RegistryValue v;')
        k.emit(f'v.shmem_nbytes = {dd.shmem_nbytes};')
        k.emit(f'v.warps_per_threadblock = {dd.warps_per_threadblock};')
        k.emit(f'v.pstate32_per_small_tree = {dd.pstate32_per_small_tree};')

        if (not input_is_ringbuf) and (not output_is_ringbuf):
            k.emit(f'v.cuda_kernel_no_rb = {dd.kernel_name};')
        elif (input_is_ringbuf) and (not output_is_ringbuf):
            k.emit(f'v.cuda_kernel_in_rb = {dd.kernel_name};')
        elif (not input_is_ringbuf) and (output_is_ringbuf):
            k.emit(f'v.cuda_kernel_out_rb = {dd.kernel_name};')
        else:
            raise RuntimeError('Error: input_is_ringbuf == output_is_ringbuf == True')

        k.emit()
        
        k.emit(f'bool debug = false;')
        k.emit(f'NewGpuDedispersionKernel::register_kernel(k,v,debug);')
        k.emit()
    
        k.emit(f'}}   // register_hack{rank} constructor')
        k.emit(f'}};  // struct register_hack{rank}')
        k.emit(f'register_hack{rank} hack{rank};')
        k.emit('}   // anonymous namespace')
        k.emit()

    k.emit('} // namespace pirate')
    return k
    

    
def make_pf_file(nbits, M, E, Dout, Dcore, W, BlocksPerSM):
    """Returns a Kernel object."""

    dtype = dtype_from_nbits(nbits)
    pars = PeakFindingParams(dtype, M, E, Dout, Dcore, W, BlocksPerSM)
    pf_full_kernel = PeakFinder(pars, reduce_only=False)
    pf_reduce_only = PeakFinder(pars, reduce_only=True)
    
    k = Kernel()
    k.emit('// Autogenerated by pirate_frb.cuda_generator')
    k.emit()
    k.emit('// For a high-level overview, see the long comment at the top of')
    k.emit('// pirate_frb/cuda_generator/PeakFinder.py')
    k.emit()
    k.emit('#include <cstdio>')
    k.emit('#include <iostream>')
    k.emit('#include <ksgpu/device_transposes.hpp>   // f16_perm()')
    k.emit('#include "../../include/pirate/PeakFindingKernel.hpp"')
    k.emit()
    k.emit('namespace pirate {')
    k.emit()

    pf_full_kernel.emit_global(k)
    k.emit()
    
    pf_reduce_only.emit_global(k)
    k.emit()

    k.emit('// Boilerplate to register the kernel when the library is loaded.')
    k.emit('namespace {')
    k.emit('struct register_hack {')
    k.emit('register_hack() {')
    k.emit()
    
    k.emit('GpuPeakFindingKernel::RegistryKey k;')
    k.emit(f'k.dtype = ksgpu::Dtype::native<{dtype}>();')
    k.emit(f'k.M = {M};')
    k.emit(f'k.E = {E};')
    k.emit(f'k.Dout = {Dout};')
    k.emit()
    
    k.emit('GpuPeakFindingKernel::RegistryValue v;')
    k.emit(f'v.Dcore = {Dcore};')
    k.emit(f'v.W = {W};')
    k.emit(f'v.P = {pars.P};')
    k.emit(f'v.P32 = {pf_full_kernel.P32};')
    k.emit(f'v.full_kernel = {pf_full_kernel.kernel_name};')
    k.emit(f'v.reduce_only_kernel = {pf_reduce_only.kernel_name};')
    k.emit()
    
    k.emit(f'bool debug = false;')
    k.emit(f'GpuPeakFindingKernel::register_kernel(k,v,debug);')
    k.emit()
    
    k.emit('}   // register_hack constructor')
    k.emit('};  // struct register hack')
    k.emit('register_hack hack;')
    k.emit('}   // anonymous namespace')
    k.emit()
    
    k.emit('} // namespace pirate')
    return k
    

def make_file(stem):
    """Returns a Kernel object.

    Example 'stem' args:

       - dedispersion kernel: 'dd_fp32_ilag0_irb0_orb0_s1'
       - peak-finding kernel: 'pf_fp32_M16_E8_Dout16_Dcore8_W4_B4'

    The stem can include an optional leading directory and a trailing '.cu'.
    For example, /path/to/pf_M16_E8_Dout16_Dcore8_W4_B4.cu matches.
    """

    # Reminder: (?:...) defines a "non-capturing group".
    m = re.match(r'^(?:.*/)?dd_fp(\d+)_ilag(0|1)_irb(0|1)_orb(0|1)_s(\d+)(?:\.cu)?', stem)
    if m:
        nbits, ilag, irb, orb, nspec = [ int(x) for x in m.groups() ]
        return make_dd_file(nbits, bool(ilag), bool(irb), bool(orb), nspec)
    
    m = re.match(r'^(?:.*/)?pf_fp(\d+)_M(\d+)_E(\d+)_Dout(\d+)_Dcore(\d+)_W(\d+)_B(\d+)(?:\.cu)?', stem)
    if m:
        nbits, M, E, Dout, Dcore, W, BlocksPerSM = [ int(x) for x in m.groups() ]
        return make_pf_file(nbits, M, E, Dout, Dcore, W, BlocksPerSM)

    raise RuntimeError(f"Couldn't match {stem=}")

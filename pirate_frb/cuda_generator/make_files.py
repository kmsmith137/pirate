import re

from .Kernel import Kernel
from .PeakFinder import PeakFinder, PeakFindingParams


def make_pf_file(nbits, M, E, Dout, Dcore, W, BlocksPerSM):
    """Returns a Kernel object."""

    if nbits == 32:
        dtype = 'float'
    elif nbits == 16:
        dtype = '__half'
    else:
        raise RuntimeError(f'Unrecognized dtype {dtype}')

    pars = PeakFindingParams(dtype, M, E, Dout, Dcore, W, BlocksPerSM)
    pf_full_kernel = PeakFinder(pars, reduce_only=False)
    pf_reduce_only = PeakFinder(pars, reduce_only=True)
    
    k = Kernel()
    k.emit('// Autogenerated by pirate_frb.cuda_generator')
    k.emit()
    k.emit('#include <cstdio>')
    k.emit('#include <ksgpu/device_transposes.hpp>   // f16_perm()')
    k.emit('#include "../../include/pirate/PeakFindingKernel.hpp"')
    k.emit()
    k.emit('namespace pirate {')
    k.emit()

    pf_full_kernel.emit_global(k)
    k.emit()
    
    pf_reduce_only.emit_global(k)
    k.emit()

    k.emit('// Boilerplate to register the kernel when the library is loaded.')
    k.emit('namespace {')
    k.emit('struct register_hack {')
    k.emit('register_hack() {')
    k.emit()
    
    k.emit('pf_kernel k;')
    k.emit(f'k.dtype = ksgpu::Dtype::native<{dtype}>();')
    k.emit(f'k.M = {M};')
    k.emit(f'k.E = {E};')
    k.emit(f'k.Dout = {Dout};')
    k.emit(f'k.Dcore = {Dcore};')
    k.emit(f'k.W = {W};')
    k.emit(f'k.P = {pars.P};')
    k.emit(f'k.P32 = {pf_full_kernel.P32};')
    k.emit(f'k.full_kernel = {pf_full_kernel.kernel_name};')
    k.emit(f'k.reduce_only_kernel = {pf_reduce_only.kernel_name};')
    k.emit(f'k.debug = false;')
    k.emit(f'k.register_kernel();')
    k.emit()
    
    k.emit('}   // register_hack constructor')
    k.emit('};  // struct register hack')
    k.emit('register_hack hack;')
    k.emit('}   // anonymous namespace')
    k.emit()
    
    k.emit('} // namespace pirate')
    return k
    

def make_file(stem):
    """Returns a Kernel object.

    Example 'stem' args:
    
       - peak-finding kernel: 'pf_M16_E8_Dout16_Dcore8_W4_B4'
       - more to come!

    The stem can include an optional leading directory and a trailing '.cu'.
    For example, /path/to/pf_M16_E8_Dout16_Dcore8_W4_B4.cu matches.
    """

    # Reminder: (?:...) defines a "non-capturing group".
    m = re.match(r'^(?:.*/)?pf_fp(\d+)_M(\d+)_E(\d+)_Dout(\d+)_Dcore(\d+)_W(\d+)_B(\d+)(?:\.cu)?', stem)
    if m:
        nbits, M, E, Dout, Dcore, W, BlocksPerSM = [ int(x) for x in m.groups() ]
        return make_pf_file(nbits, M, E, Dout, Dcore, W, BlocksPerSM)

    raise RuntimeError(f"Couldn't match {stem=}")

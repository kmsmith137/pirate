import re

from .Kernel import Kernel
from .PeakFinder import PeakFinder, PeakFindingParams
from .Dedisperser import Dedisperser, DedisperserParams


def dtype_from_nbits(nbits):
    if nbits == 32:
        return 'float'
    if nbits == 16:
        return '__half'
    raise RuntimeError(f'Unrecognized dtype {dtype}')

    
def make_dd_file(nbits):
    """Returns a Kernel object."""

    dtype = dtype_from_nbits(nbits)    
    k = Kernel()
    
    k.emit('// Autogenerated by pirate_frb.cuda_generator')
    k.emit()
    k.emit('// For a high-level overview, see comments at the top of')
    k.emit('// pirate_frb/cuda_generator/Dedisperser.py')
    k.emit()
    k.emit('#include <cstdio>')
    k.emit('#include <iostream>')
    k.emit('#include <ksgpu/device_transposes.hpp>   // f16_perm()')    
    k.emit('#include "../../include/pirate/DedispersionKernel.hpp"')
    k.emit()
    k.emit('namespace pirate {')
    k.emit()

    k_code = k.splice()

    for rank in [6]:
        pars = DedisperserParams(dtype, rank)
        dd = Dedisperser(pars)
        
        dd.emit_global(k_code)
        k_code.emit()

        k.emit(f'// Boilerplate to register the rank={rank} kernel when the library is loaded.')
        k.emit('namespace {')
        k.emit(f'struct register_hack{rank} {{')
        k.emit(f'register_hack{rank}() {{')
        k.emit()
    
        k.emit('dd_kernel k;')
        k.emit(f'k.dtype = ksgpu::Dtype::native<{dtype}>();')
        k.emit(f'k.rank = {rank};')
        k.emit(f'k.input_is_ringbuf = false;')
        k.emit(f'k.output_is_ringbuf = false;')
        k.emit(f'k.apply_input_residual_lags = false;')
        k.emit(f'k.cuda_kernel = {dd.kernel_name};')
        k.emit(f'k.shmem_nbytes = {dd.shmem_nbytes};')
        k.emit(f'k.warps_per_threadblock = {dd.warps_per_threadblock};')
        k.emit(f'k.pstate32_per_small_tree = {dd.pstate32_per_small_tree};')
        k.emit(f'k.debug = false;')
        k.emit(f'k.register_kernel();')
        k.emit()
    
        k.emit(f'}}   // register_hack{rank} constructor')
        k.emit(f'}};  // struct register_hack{rank}')
        k.emit(f'register_hack{rank} hack{rank};')
        k.emit('}   // anonymous namespace')
        k.emit()

    k.emit('} // namespace pirate')
    return k
    

    
def make_pf_file(nbits, M, E, Dout, Dcore, W, BlocksPerSM):
    """Returns a Kernel object."""

    dtype = dtype_from_nbits(nbits)
    pars = PeakFindingParams(dtype, M, E, Dout, Dcore, W, BlocksPerSM)
    pf_full_kernel = PeakFinder(pars, reduce_only=False)
    pf_reduce_only = PeakFinder(pars, reduce_only=True)
    
    k = Kernel()
    k.emit('// Autogenerated by pirate_frb.cuda_generator')
    k.emit()
    k.emit('// For a high-level overview, see the long comment at the top of')
    k.emit('// pirate_frb/cuda_generator/PeakFinder.py')
    k.emit()
    k.emit('#include <cstdio>')
    k.emit('#include <iostream>')
    k.emit('#include <ksgpu/device_transposes.hpp>   // f16_perm()')
    k.emit('#include "../../include/pirate/PeakFindingKernel.hpp"')
    k.emit()
    k.emit('namespace pirate {')
    k.emit()

    pf_full_kernel.emit_global(k)
    k.emit()
    
    pf_reduce_only.emit_global(k)
    k.emit()

    k.emit('// Boilerplate to register the kernel when the library is loaded.')
    k.emit('namespace {')
    k.emit('struct register_hack {')
    k.emit('register_hack() {')
    k.emit()
    
    k.emit('pf_kernel k;')
    k.emit(f'k.dtype = ksgpu::Dtype::native<{dtype}>();')
    k.emit(f'k.M = {M};')
    k.emit(f'k.E = {E};')
    k.emit(f'k.Dout = {Dout};')
    k.emit(f'k.Dcore = {Dcore};')
    k.emit(f'k.W = {W};')
    k.emit(f'k.P = {pars.P};')
    k.emit(f'k.P32 = {pf_full_kernel.P32};')
    k.emit(f'k.full_kernel = {pf_full_kernel.kernel_name};')
    k.emit(f'k.reduce_only_kernel = {pf_reduce_only.kernel_name};')
    k.emit(f'k.debug = false;')
    k.emit(f'k.register_kernel();')
    k.emit()
    
    k.emit('}   // register_hack constructor')
    k.emit('};  // struct register hack')
    k.emit('register_hack hack;')
    k.emit('}   // anonymous namespace')
    k.emit()
    
    k.emit('} // namespace pirate')
    return k
    

def make_file(stem):
    """Returns a Kernel object.

    Example 'stem' args:

       - dedispersion kernel: 'dd_pf32'
       - peak-finding kernel: 'pf_fp32_M16_E8_Dout16_Dcore8_W4_B4'

    The stem can include an optional leading directory and a trailing '.cu'.
    For example, /path/to/pf_M16_E8_Dout16_Dcore8_W4_B4.cu matches.
    """

    # Reminder: (?:...) defines a "non-capturing group".
    m = re.match(r'^(?:.*/)?dd_fp(\d+)(?:\.cu)?', stem)
    if m:
        nbits = int(m.group(1))
        return make_dd_file(nbits)
    
    m = re.match(r'^(?:.*/)?pf_fp(\d+)_M(\d+)_E(\d+)_Dout(\d+)_Dcore(\d+)_W(\d+)_B(\d+)(?:\.cu)?', stem)
    if m:
        nbits, M, E, Dout, Dcore, W, BlocksPerSM = [ int(x) for x in m.groups() ]
        return make_pf_file(nbits, M, E, Dout, Dcore, W, BlocksPerSM)

    raise RuntimeError(f"Couldn't match {stem=}")

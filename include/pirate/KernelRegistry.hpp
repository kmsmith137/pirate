#ifndef _PIRATE_KERNEL_REGISTRY_HPP
#define _PIRATE_KERNEL_REGISTRY_HPP

#include <mutex>
#include <vector>
#include <string>
#include <sstream>
#include <iostream>
#include <stdexcept>
#include <ksgpu/rand_utils.hpp>


namespace pirate {
#if 0
}  // editor auto-indent
#endif


// This header-only source file defines 'struct KernelRegistry', a lookup table
// for precompiled cuda kernels.
//
// For "documentation by example", see the dedispersion kernel registry:
//
//   - include/pirate/DedisperionKernel.hpp: contains definitions of
//        GpuDedispersionKernel::RegistryKey
//        GpuDedispersionKernel::RegistryValue
//        GpuDedispersionKernel::Registry
//
//   - src_lib/DedispersionKernel.cu: a few function definitions
//     (note in particular DedispRegistry::deferred_initialization())
//
//   - src_lib/autogenerated_kernels/dd_*.cu: low-level registrations
//     of cuda kernels.
//
// When defining a registry, the following functions should be defined:
//
//   bool operator==(const Key &k1, const Key &k2);
//   ostream &operator<<(ostream &os, const Key &k);
//   ostream &operator<<(ostream &os, const Val &v);
//
// Don't forget to add your registry to show_kernels() in utils.cu.


template<class Key, class Val>
struct KernelRegistry
{
    struct Entry
    {
        Key key;
        Val val;
        bool debug = false;        // debug kernel "clobbers" non-debug kernel
        bool initialized = false;  // has deferred_initialization() been called?
    };
    
    mutable std::mutex lock;
    std::vector<Entry> entries;
    
    // deferred_initialization(): this optional method performs initializations which
    // are "deferred" from when the kernel is registered, to when the kernel is first
    // used. For an example, see src_lib/GpuDedispersionKernel.cu.
    //
    // It's important to defer calls to the cuda runtime library (e.g. setting shared
    // memory size for a kernel). Such calls may misbehave at library initialization
    // time, but behave normally if "deferred". Warning: this can be hard to debug!
    // Sometimes, the non-deferred call appears to succeed, but an unrelated kernel
    // launch will fail later with error 400 ("invalid resource handle").
    
    virtual void deferred_initialization(Val &val) { }

    
    KernelRegistry() { }

    // Call with lock held!
    // Returned pointer is only valid until lock is dropped.
    Entry *_get_locked(const Key &key)
    {
        for (Entry &e: entries)
            if (e.key == key)
                return &e;
        return nullptr;
    }


    // Subclass can override add(), e.g. for error-checking.
    virtual void add(const Key &key, const Val &val, bool debug)
    {
        Entry enew;
        enew.key = key;
        enew.val = val;
        enew.debug = debug;
        
        std::unique_lock<std::mutex> lk(this->lock);
        Entry *e = this->_get_locked(key);

        if (!e) {
            this->entries.push_back(enew);
            return;
        }

        if (!e->debug && debug)
            *e = enew;   // clobber and fall through
        else if (!e->debug || debug) {
            std::stringstream ss;
            ss << "KernelRegistry::add() called twice, perhaps you forgot to set the 'debug' flag? Kernel is: " << key;
            throw std::runtime_error(ss.str());
        }

        // If we get here, then both a debug and non-debug kernel were registered.
        // This is not an error, but we print an informational message.

        std::cout << "\nNote: debug and non-debug kernels were registered; debug kernel takes priority"
                  << "\nKernel is: " << key << "\n\n";
    }


    Val get(const Key &key)
    {
        std::unique_lock<std::mutex> lk(this->lock);
        Entry *e = this->_get_locked(key);

        if (!e) {
            lk.unlock();
            std::stringstream ss;
            ss << "Kernel not found in registry: " << key;
            throw std::runtime_error(ss.str());
        }

        if (!e->initialized) {
            this->deferred_initialization(e->val);
            e->initialized = true;
        }
        
        Val ret = e->val;
        lk.unlock();
        return ret;
    }

    bool has_key(const Key &key)
    {
        std::unique_lock<std::mutex> lk(this->lock);
        Entry *e = this->_get_locked(key);
        return (e != nullptr);
    }

    Key get_random_key()
    {
        std::unique_lock<std::mutex> lk(this->lock);
        
        if (entries.size() == 0)
            throw std::runtime_error("KernelRegistry::get_random() called on empty registry");
            
        long i = ksgpu::rand_int(0, entries.size());
        Key ret = entries[i].key;
        lk.unlock();
        return ret;
    }


    std::vector<Key> get_all_keys()
    {
        std::unique_lock<std::mutex> lk(this->lock);
        std::vector<Key> ret;
        ret.reserve(entries.size());
        for (const Entry &e: entries)
            ret.push_back(e.key);
        lk.unlock();
        return ret;
    }


    long size()
    {
        std::unique_lock<std::mutex> lk(this->lock);
        long ret = entries.size();
        lk.unlock();
        return ret;
    }


    virtual void show(std::ostream &os = std::cout)
    {
        // FIXME ordering is arbitrary; could improve by sorting keys.

        std::unique_lock<std::mutex> lk(this->lock);

        for (ulong i = 0; i < entries.size(); i++) {
            os << "    [" << i << "]: " << entries[i].key << "\n";
            
            std::stringstream ss;
            ss << entries[i].val;
            
            std::string s = ss.str();
            if (!s.empty())
                os << "        " << entries[i].val << "\n";
        }

        os << std::flush;
    }
};


}  // namespace pirate

#endif // _PIRATE_KERNEL_REGISTRY_HPP

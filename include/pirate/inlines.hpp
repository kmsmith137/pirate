#ifndef _PIRATE_INLINES_HPP
#define _PIRATE_INLINES_HPP

#include <ksgpu/xassert.hpp>
#include <ksgpu/string_utils.hpp>  // ksgpu::nbytes_to_str()

#include <cmath>
#include <string>
#include <iostream>
#include <algorithm>
#include <cuda_fp16.h>  // __half, __half2

namespace pirate {
#if 0
}  // editor auto-indent
#endif


inline bool is_power_of_two(long n)
{
    return (n > 0) && !(n & (n-1));
}

inline long pow2(int n)
{
    xassert((n >= 0) && (n <= 32));
    return 1L << n;
}

inline long align_up(long n, long nalign)
{
    xassert(n >= 0);
    xassert(nalign > 0);
    xassert(is_power_of_two(nalign));
    return (n + nalign - 1) & ~(nalign - 1);
}

inline long round_up_to_power_of_two(long n)
{
    if (n <= 1)
        return 1;
    double x = log2(n - 0.5);
    return 1L << (int(x) + 1);
}

inline long round_down_to_power_of_two(long n)
{
    xassert(n >= 1);
    double x = log2(n + 0.5);
    return 1L << int(x);
}

inline long xdiv(long m, long n)
{
    xassert(m >= 0);
    xassert(n > 0);
    xassert_divisible(m, n);
    return m/n;
}

inline long xmod(long m, long n)
{
    xassert(m >= 0);
    xassert(n > 0);
    return m % n;
}

template<typename T>
inline T square(T x)
{
    return x*x;
}

inline bool is_empty_string(const std::string &s)
{
    return s.size() == 0;
}

template<typename T>
inline bool is_sorted(const std::vector<T> &v, bool reversed=false)
{
    for (unsigned int i = 1; i < v.size(); i++) {
        if (v[i-1] == v[i])
            return false;
        if (!reversed && (v[i-1] > v[i]))
            return false;
        if (reversed && (v[i-1] < v[i]))
            return false;
    }

    return true;
}

inline bool is_aligned(const void *ptr, int nalign, bool allow_null=false)
{
    if (!allow_null && !ptr)
        return false;
    
    xassert(nalign > 0);
    return (((unsigned long)ptr) % nalign) == 0;
}


// Compares a std::vector and a std::initializer_list.
// (Useful in some of the autogenerated cuda kernels.)
template<typename T1, typename T2>
inline bool vec_equal(const std::vector<T1> &v, const std::initializer_list<T2> &w)
{
    return (v.size() == w.size()) && std::equal(v.begin(), v.end(), w.begin());
}


// -------------------------------------------------------------------------------------------------
//
// simd32_type<T>::type
//   -> float if T=float (or any other 32-bit type)
//   -> __half2 if T=__half

template<typename T>
struct simd32_type
{
    static_assert(sizeof(T) == 4);
    using type = T;
};


template<>
struct simd32_type<__half>
{
    using type = __half2;
};


}  // namespace pirate

#endif // _PIRATE_INLINES_HPP


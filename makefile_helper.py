#!/usr/bin/env python
#
# This script is invoked by the Makefile, to generate "derived" Makefile variables:
#
#   - PYTHON_INCDIR
#   - NUMPY_INCDIR
#   - PYBIND11_INCDIR
#   - PYEXT_SUFFIX
#   - KSGPU_DIR
#   - AUTOGENERATED_KERNELS
#
# Values of these variables are written to makefile_helper.out.


# These global boolean variables are used to control which kernels are procedurally generated.
# This is a tradeoff between coverage and compile time.
#
# In "production" builds, I set production_kernels=True, and debug_*_kernels=False.
# When developing, I usually set all flags to False, so that compile times are short.
# If I'm debugging something specific, then I'll set a debug flag.
# For a long CI-style test run, I'll set all flags to true (high compile time!)

production_kernels = False    # "production" CHIME/CHORD kernels (default True)
debug_dd_kernels = False      # debug dedispersion kernels (default False)
debug_pf_kernels = True       # debug peak-finding kernels (default False)
debug_pfo_kernels = False     # debug peak-finding output microkernel (default False)
debug_pfwr_kernels = False    # debug peak-finding weight reader kernels (default False)
debug_cdd2_kernels = False    # debug coalesced dedispersion-pf kernels (default False)
debug_gpu_dd = False          # end-to-end test of gpu dedisperser


####################################################################################################


import io
import os
import sys
import sysconfig
import importlib.util

try:
    import pybind11
except:
    raise RuntimeError("Couldn't import pybind11 -- this is a fatal error")

try:
    import numpy
except:
    raise RuntimeError("Couldn't import numpy -- this is a fatal error")

# This way of getting KSGPU_DIR is awkward, but avoids importing 'ksgpu'.
# (This is useful since imports can generate unexpected output.)
ksgpu_spec = importlib.util.find_spec('ksgpu')
if ksgpu_spec is None:
    raise RuntimeError("Couldn't find 'ksgpu' package -- this is a fatal error")

# This way of importing 'pirate_frb.cuda generator' doesn't assume that the
# larger 'pirate_frb' package has been built or installed.
sys.path.insert(0, 'pirate_frb')
import cuda_generator


####################################################################################################


def main():
    s = io.StringIO()
    print("# Autogenerated by makefile_helper.py (which is automatically invoked by the Makefile)\n", file=s)

    python_incdir = sysconfig.get_config_var('INCLUDEPY')
    print("# Include directory for python headers", file=s)
    print("# From sysconfig.get_config_var('INCLUDEPY')", file=s)
    print(f"PYTHON_INCDIR = {python_incdir}\n", file=s)

    numpy_incdir = numpy.get_include()
    print("# Include directory for numpy headers", file=s)
    print("# From numpy.get_include()", file=s)
    print(f"NUMPY_INCDIR = {numpy_incdir}\n", file=s)

    pybind11_incdir = pybind11.get_include()
    print("# Include directory for pybind11 headers", file=s)
    print("# From pybind11.get_include()", file=s)
    print(f"PYBIND11_INCDIR = {pybind11_incdir}\n", file=s)

    pyext_suffix = sysconfig.get_config_var('EXT_SUFFIX')
    print("# Filename suffix for python extension modules", file=s)
    print("# From sysconfig.get_config_var('EXT_SUFFIX')", file=s)
    print("# Equivalent to 'python3-config --extension-suffix'", file=s)
    print(f"PYEXT_SUFFIX = {pyext_suffix}\n", file=s)

    ksgpu_dir = os.path.dirname(ksgpu_spec.origin)
    print("# Base directory for 'ksgpu' package", file=s)
    print("# From importlib.util.find_spec('ksgpu').origin", file=s)
    print(f"KSGPU_DIR = {ksgpu_dir}\n", file=s)

    print("# CUDA kernels that will be autogenerated (by running ./autogenerate_kernel.py)", file=s)
    print('AUTOGENERATED_KERNELS =', end='', file=s)
    for filename in autogenerated_kernel_filenames():
        print(f' \\\n    {filename}', end='', file=s)
    print(file=s)

    s = s.getvalue()
    outfile = 'makefile_helper.out'
    print(f'Writing {outfile}')

    with open(outfile,'w') as f:
        print(s, file=f, end='')

    # Show summary on stdout (for debugging).
    if False:
        for line in s.split('\n'):
            if (len(line) > 0) and (line[0] != '#'):
                print('   ', line)


####################################################################################################


def autogenerated_kernel_filenames():
    """Top-level generator for autogenerated kernels."""
    
    duplicate_checker = set()
    for basename in autogenerated_kernel_basenames():  # defined below
        if basename not in duplicate_checker:
            duplicate_checker.add(basename)
            yield f'src_lib/autogenerated_kernels/{basename}'


def autogenerated_kernel_basenames():
    for kernel in autogenerated_dedispersion_kernels():
        yield kernel.kernel_basename
    
    for kernel in autogenerated_peak_finding_kernels():
        for basename in kernel.all_kernel_basenames:
            yield basename

    for kernel in autogenerated_cdd2_kernels():
        for basename in kernel.all_kernel_basenames:
            yield basename
    
    for kernel in autogenerated_pf_weight_reader_kernels():
        yield kernel.kernel_basename

    for kernel in autogenerated_pf_output_kernels():
        yield kernel.kernel_basename


def autogenerated_dedispersion_kernels():
    """
    Generates objects of type 'cuda_generator.MultiDedisperser'.
    Duplicates are okay here (they'll be caught later, see 'duplicate_checker' above.)
    """
    
    T, F = True, False

    # Triples are of the form (input_is_ringbuf, output_is_ringbuf, apply_input_residual_lags).
    # We always generate enough kernels to run 'pirate_frb -m test --dd', even if debug_dd_kernels == False.
    triples = [ (F,F,F), (F,T,F), (T,F,T) ]

    if debug_dd_kernels:
        triples += [ (F,F,T), (F,T,T), (T,F,F) ]

    for dtype in [ 'float', '__half' ]:
        for irb,orb,rlag in triples:
            nspec_list = [1,8] if debug_dd_kernels else [1]
            for nspec in nspec_list:
                yield cuda_generator.MultiDedisperser(
                    dtype = dtype,
                    apply_input_residual_lags = rlag,
                    input_is_ringbuf = irb,
                    output_is_ringbuf = orb,
                    nspec = nspec
                )

        
def autogenerated_peak_finding_kernels():
    """
    Generates objects of type 'cuda_generator.PeakFinder'.
    Duplicates are okay here (they'll be caught later, see 'duplicate_checker' above.)
    """

    # The parameter space (dtype, subband_counts, Wmax, Dcore, Dout, Tinner) is too
    # large to enumerate, so we chooise a few representative kernels.

    # "Corners" of parameter space (16 kernels total)
    # Subband counts here are randomly generated.

    if not debug_pf_kernels:
        return
    
    kernels = [
        ('fp32', (1,1), 1, 1, 1, 1),
        ('fp32', (5,5,2,1), 1, 1, 1, 32),
        ('fp32', (0,8,2,2,1), 1, 1, 32, 1),
        ('fp32', (7,0,3,1,1), 1, 32, 32, 1),
        ('fp32', (0,2,0,1), 16, 1, 1, 1),
        ('fp32', (1,1), 16, 1, 1, 32),
        ('fp32', (0,1), 16, 1, 32, 1),
        ('fp32', (2,11,1,0,1), 32, 32, 32, 1),
        ('fp16', (1,1), 1, 2, 2, 1),
        ('fp16', (3,6,5,2,1), 1, 2, 2, 32),
        ('fp16', (2,3,1,1), 1, 2, 32, 1),
        ('fp16', (0,3,2,1), 1, 32, 32, 1),
        ('fp16', (3,2,1), 32, 2, 2, 1),
        ('fp16', (2,1), 32, 2, 2, 32),
        ('fp16', (1,1,1), 32, 2, 32, 1),
        ('fp16', (3,4,2,1), 32, 32, 32, 1),
    ]

    # Add some randomly generated kernels.
    # python -m pirate_frb random_kernels --pf

    kernels += [
        ('fp32', (3, 1, 0, 1), 4, 1, 2, 1),
        ('fp16', (9, 0, 2, 2, 1), 2, 2, 2, 8),
        ('fp16', (1, 5, 2, 0, 1), 8, 4, 8, 4),
        ('fp32', (6, 3, 2, 1), 1, 2, 8, 4),
        ('fp32', (1, 4, 1, 1), 16, 4, 4, 2),
        ('fp16', (0, 1), 8, 4, 4, 8),
        ('fp32', (3, 1, 1), 1, 8, 16, 1),
        ('fp32', (1, 5, 6, 0, 1), 2, 4, 8, 2),
        ('fp16', (2, 6, 0, 1), 16, 8, 16, 4),
        ('fp32', (8, 11, 1, 1, 1), 1, 1, 4, 2),
        ('fp16', (4, 6, 0, 1), 4, 8, 32, 2),
        ('fp16', (0, 2, 1), 16, 8, 8, 4),
        ('fp16', (5, 3, 2, 1), 2, 16, 32, 2),
        ('fp16', (2, 3, 1), 4, 2, 8, 2),
        ('fp16', (2, 1, 2, 1), 8, 8, 16, 2)
    ]

    for dtype, subband_counts, Wmax, Dcore, Dout, Tinner in kernels:
        fs = cuda_generator.FrequencySubbands(subband_counts = subband_counts)
        yield cuda_generator.PeakFinder(dtype, fs, Wmax, Dcore, Dout, Tinner)

    
def autogenerated_cdd2_kernels():
    """
    Generates objects of type 'cuda_generator.CoalescedDdKernel2'.
    Duplicates are okay here (they'll be caught later, see 'duplicate_checker' above.)
    """

    # Start with one "baseline" kernel, so that unit tests can run even if all boolean flags are False.
    # (dtype, dd_rank, subband_counts, Wmax, Dcore, Dout, Tinner)
    kernels = [ ('fp16', 5, (0,1,2,1), 16, 8, 16, 1) ]

    if production_kernels:
        # Note: these subband schemes also appear in CoalescedDdKernel2::time(), 
        # so any changes made here should be reflected there.
        sc_none = (0,0,0,0,1)    # no subbands
        sc_chime1 = (0,0,1,2,1)  # python -m pirate_frb show_subbands --rank=4 --fmin=400 --fmax=800 --threshold=0.3
        sc_chime2 = (0,5,7,3,1)  # python -m pirate_frb show_subbands --rank=4 --fmin=400 --fmax=800 --threshold=0.1
        sc_chord1 = (1,2,2,2,1)  # python -m pirate_frb show_subbands --rank=4 --fmin=300 --fmax=1500 --threshold=0.4
        sc_chord2 = (5,9,7,3,1)  # python -m pirate_frb show_subbands --rank=4 --fmin=300 --fmax=1500 --threshold=0.1

        Dout = 16
        Dcore = 8
        Tinner = 1

        # FIXME I'd like to use Wmax=32, but that currently fails!
        Wmax = 16

        for dtype in ['fp32','fp16']:
            for dd_rank in [7,8]: 
                for subband_counts in [sc_none, sc_chime1, sc_chime2, sc_chord1, sc_chord2]:
                    kernels += [ (dtype, dd_rank, subband_counts, Wmax, Dcore, Dout, Tinner) ]
        
    if debug_cdd2_kernels or debug_gpu_dd:
        # Add some randomly generated kernels.
        # python -m pirate_frb random_kernels --cdd2

        kernels += [
            # (dtype, dd_rank, subband_counts, Wmax, Dcore, Dout, Tinner)
            ('fp32', 5, (6, 1, 1, 1), 16, 2, 2, 4),
            ('fp16', 6, (0, 0, 0, 1), 1, 4, 16, 2),
            ('fp32', 7, (11, 10, 1, 1, 1), 4, 2, 4, 4),
            ('fp16', 3, (3, 1, 1), 16, 4, 8, 4),
            ('fp16', 5, (7, 0, 0, 1), 1, 4, 4, 8),
            ('fp32', 5, (0, 1, 0, 1), 1, 2, 2, 8),
            ('fp16', 5, (6, 1, 2, 1), 2, 8, 8, 2),
            ('fp32', 8, (10, 9, 2, 2, 1), 2, 2, 8, 4),
            ('fp16', 7, (15, 6, 1, 0, 1), 1, 2, 8, 2),
            ('fp16', 4, (0, 0, 1), 8, 4, 8, 4), 
            ('fp32', 7, (3, 7, 6, 2, 1), 16, 2, 4, 8),  
            ('fp32', 7, (15, 3, 6, 1, 1), 4, 2, 2, 8),
            ('fp32', 8, (2, 0, 5, 0, 1), 4, 4, 8, 2),
            ('fp16', 4, (1, 1, 1), 16, 16, 16, 4),
            ('fp16', 3, (3, 1, 1), 8, 16, 32, 1),
            ('fp16', 4, (0, 2, 1), 16, 8, 8, 8),
            ('fp32', 4, (3, 0, 1), 16, 2, 16, 2),
            ('fp32', 5, (0, 5, 1, 1), 4, 2, 8, 2),
            ('fp32', 5, (5, 5, 2, 1), 4, 1, 1, 4),
            ('fp32', 7, (1, 12, 6, 0, 1), 2, 4, 16, 2),
            ('fp16', 7, (11,0,0,0,1), 1, 8, 16, 2)
        ]

    if debug_gpu_dd:
        kernels0 = kernels
        kernels = [ ]

        # For every cdd2 kernel in the 'kernels' list, we generate a few more kernels
        # which are related by downsampling or early triggering.

        for dtype, dd_rank0, subband_counts, Wmax, Dcore, Dout, Tinner in kernels0:
            pf_rank0 = (dd_rank0 + 1) // 2
            sc0 = cuda_generator.FrequencySubbands.rerank_subband_counts(subband_counts, pf_rank0)

            for ds_rank in [dd_rank0-1, dd_rank0]:   # downsampled dd rank
                for et_rank in [ds_rank-2, ds_rank-1, ds_rank]:
                    if et_rank < 3:
                        continue
                
                    pf_rank = (et_rank + 1) // 2
                    delta_rank = ds_rank - et_rank    
                    sc = cuda_generator.FrequencySubbands.early_subband_counts(sc0, delta_rank)
                    sc = cuda_generator.FrequencySubbands.rerank_subband_counts(sc, pf_rank)
                    kernels.append((dtype, et_rank, sc, Wmax, Dcore, Dout, Tinner))

    for dtype, dd_rank, subband_counts, Wmax, Dcore, Dout, Tinner in kernels:
        fs = cuda_generator.FrequencySubbands(subband_counts = subband_counts)
        cdd2 = cuda_generator.CoalescedDdKernel2(dtype, dd_rank, fs, Wmax, Dcore, Dout, Tinner)
        yield cdd2


def autogenerated_pf_weight_reader_kernels():
    """
    Generates objects of type 'cuda_generator.PfWeightReader'.
    Duplicates are okay here (they'll be caught later, see 'duplicate_checker' above.)
    """

    if not debug_pfwr_kernels:
        return
    
    # Add some randomly generated kernels.
    # python -m pirate_frb random_kernels --pfwr

    # (dtype, subband_counts, Dcore, P, Tinner)
    kernels = [
        ('fp32', (2,1,1), 1, 14, 16),
        ('fp16', (7,6,2,1), 8, 10, 2),
        ('fp32', (0,2,1), 1, 1, 4),
        ('fp16', (4,0,1,1), 2, 5, 1),
        ('fp32', (3,2,1), 1, 5, 32),
        ('fp16', (14,4,4,0,1), 8, 3, 2),
        ('fp16', (13,7,3,0,1), 4, 3, 4),
        ('fp16', (3,2,1), 2, 7, 32),
        ('fp32', (6,5,1,1,1), 4, 2, 4),
        ('fp32', (4,3,1,1), 2, 2, 8),
        ('fp32', (3,2,1), 8, 5, 4),
        ('fp16', (1,1,1), 4, 2, 1),
        ('fp32', (9,4,0,2,1), 16, 8, 1),
        ('fp32', (0,2,1), 1, 8, 2),
        ('fp32', (3,0,1), 1, 6, 1)
    ]

    for (dtype, subband_counts, Dcore, P, Tinner) in kernels:
        fs = cuda_generator.FrequencySubbands(subband_counts = subband_counts)
        yield cuda_generator.PfWeightReader(fs, dtype, Dcore, P, Tinner)


def autogenerated_pf_output_kernels():
    """
    Generates objects of type 'cuda_generator.PfOutput'.
    Duplicates are okay here (they'll be caught later, see 'duplicate_checker' above.)
    """

    # In this case, we can enumerate all valid parameter choices
    # (i.e. no need to randomly generate kernels).

    if not debug_pfo_kernels:
        return
    
    for (dtype,Lmin) in [ ('float',0), ('__half',1) ]:
        for L in range(Lmin, 6):
            yield cuda_generator.PfOutput(dtype, Dout=2**L)


####################################################################################################


if __name__ == '__main__':
    main()
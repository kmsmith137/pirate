#!/usr/bin/env python
#
# This script is invoked by the Makefile, to generate "derived" Makefile variables:
#
#   - PYTHON_INCDIR
#   - NUMPY_INCDIR
#   - PYBIND11_INCDIR
#   - PYEXT_SUFFIX
#   - KSGPU_DIR
#   - AUTOGENERATED_KERNELS
#
# Values of these variables are written to makefile_helper.out.


# These global boolean variables are used to control which kernels are procedurally generated.
# This is a tradeoff between coverage and compile time.
#
# By default, we set production_kernels=True, and debug_*_kernels=False.
# When debugging, it's sometimes useful to disable production kernels, and/or enable debug kernels.
# I try to avoid git commits with non-default settings of these flags.

production_kernels = True     # "production" CHIME/CHORD kernels (default True)
debug_dd_kernels = False      # debug dedispersion kernels (default False)
debug_pf_kernels = False      # debug peak-finding kernels (default False)
debug_pfo_kernels = False     # debug peak-finding output microkernel (default False)
debug_pfwr_kernels = False    # debug peak-finding weight reader kernels (default False)
debug_cdd2_kernels = False    # debug coalesced dedispersion-pf kernels (default False)


####################################################################################################


import io
import os
import sys
import sysconfig
import importlib.util

try:
    import pybind11
except:
    raise RuntimeError("Couldn't import pybind11 -- this is a fatal error")

try:
    import numpy
except:
    raise RuntimeError("Couldn't import numpy -- this is a fatal error")

# This way of getting KSGPU_DIR is awkward, but avoids importing 'ksgpu'.
# (This is useful since imports can generate unexpected output.)
ksgpu_spec = importlib.util.find_spec('ksgpu')
if ksgpu_spec is None:
    raise RuntimeError("Couldn't find 'ksgpu' package -- this is a fatal error")

# This way of importing 'pirate_frb.cuda generator' doesn't assume that the
# larger 'pirate_frb' package has been built or installed.
sys.path.insert(0, 'pirate_frb')
import cuda_generator


####################################################################################################


def main():
    s = io.StringIO()
    print("# Autogenerated by makefile_helper.py (which is automatically invoked by the Makefile)\n", file=s)

    python_incdir = sysconfig.get_config_var('INCLUDEPY')
    print("# Include directory for python headers", file=s)
    print("# From sysconfig.get_config_var('INCLUDEPY')", file=s)
    print(f"PYTHON_INCDIR = {python_incdir}\n", file=s)

    numpy_incdir = numpy.get_include()
    print("# Include directory for numpy headers", file=s)
    print("# From numpy.get_include()", file=s)
    print(f"NUMPY_INCDIR = {numpy_incdir}\n", file=s)

    pybind11_incdir = pybind11.get_include()
    print("# Include directory for pybind11 headers", file=s)
    print("# From pybind11.get_include()", file=s)
    print(f"PYBIND11_INCDIR = {pybind11_incdir}\n", file=s)

    pyext_suffix = sysconfig.get_config_var('EXT_SUFFIX')
    print("# Filename suffix for python extension modules", file=s)
    print("# From sysconfig.get_config_var('EXT_SUFFIX')", file=s)
    print("# Equivalent to 'python3-config --extension-suffix'", file=s)
    print(f"PYEXT_SUFFIX = {pyext_suffix}\n", file=s)

    ksgpu_dir = os.path.dirname(ksgpu_spec.origin)
    print("# Base directory for 'ksgpu' package", file=s)
    print("# From importlib.util.find_spec('ksgpu').origin", file=s)
    print(f"KSGPU_DIR = {ksgpu_dir}\n", file=s)

    print("# CUDA kernels that will be autogenerated (by running ./autogenerate_kernel.py)", file=s)
    print('AUTOGENERATED_KERNELS =', end='', file=s)
    for filename in autogenerated_kernel_filenames():
        print(f' \\\n    {filename}', end='', file=s)
    print(file=s)

    s = s.getvalue()
    outfile = 'makefile_helper.out'
    print(f'Writing {outfile}')

    with open(outfile,'w') as f:
        print(s, file=f, end='')

    # Show summary on stdout (for debugging).
    if False:
        for line in s.split('\n'):
            if (len(line) > 0) and (line[0] != '#'):
                print('   ', line)


####################################################################################################


def autogenerated_kernel_filenames():
    """Top-level generator for autogenerated kernels."""
    
    duplicate_checker = set()
    for basename in autogenerated_kernel_basenames():  # defined below
        if basename not in duplicate_checker:
            duplicate_checker.add(basename)
            yield f'src_lib/autogenerated_kernels/{basename}'


def autogenerated_kernel_basenames():
    for kernel in autogenerated_dedispersion_kernels():
        yield kernel.kernel_basename
    
    for kernel in autogenerated_peak_finding_kernels():
        for basename in kernel.all_kernel_basenames:
            yield basename

    for kernel in autogenerated_cdd2_kernels():
        for basename in kernel.all_kernel_basenames:
            yield basename
    
    for kernel in autogenerated_pf_weight_reader_kernels():
        yield kernel.kernel_basename

    for kernel in autogenerated_pf_output_kernels():
        yield kernel.kernel_basename


def autogenerated_dedispersion_kernels():
    """Generates objects of type 'cuda_generator.MultiDedisperser'."""

    
    T, F = True, False

    # Triples are of the form (input_is_ringbuf, output_is_ringbuf, apply_input_residual_lags).
    # We always generate enough kernels to run 'pirate_frb -m test --dd', even if debug_dd_kernels == False.
    triples = [ (F,F,F), (F,T,F), (T,F,T) ]

    if debug_dd_kernels:
        triples += [ (F,F,T), (F,T,T), (T,F,F) ]

    for dtype in [ 'float', '__half' ]:
        for irb,orb,rlag in triples:
            nspec_list = [1,8] if debug_dd_kernels else [1]
            for nspec in nspec_list:
                yield cuda_generator.MultiDedisperser(
                    dtype = dtype,
                    apply_input_residual_lags = rlag,
                    input_is_ringbuf = irb,
                    output_is_ringbuf = orb,
                    nspec = nspec
                )

        
def autogenerated_peak_finding_kernels():
    # The parameter space (dtype, subband_counts, W, Dcore, Dout, Tinner) is too
    # large to enumerate, so we chooise a few representative kernels.

    # "Corners" of parameter space (16 kernels total)
    # Subband counts here are randomly generated.

    if not debug_pf_kernels:
        return
    
    kernels = [
        ('fp32', (1,1), 1, 1, 1, 1),
        ('fp32', (5,5,2,1), 1, 1, 1, 32),
        ('fp32', (0,8,2,2,1), 1, 1, 32, 1),
        ('fp32', (7,0,3,1,1), 1, 32, 32, 1),
        ('fp32', (0,2,0,1), 16, 1, 1, 1),
        ('fp32', (1,1), 16, 1, 1, 32),
        ('fp32', (0,1), 16, 1, 32, 1),
        ('fp32', (2,11,1,0,1), 32, 32, 32, 1),
        ('fp16', (1,1), 1, 2, 2, 1),
        ('fp16', (3,6,5,2,1), 1, 2, 2, 32),
        ('fp16', (2,3,1,1), 1, 2, 32, 1),
        ('fp16', (0,3,2,1), 1, 32, 32, 1),
        ('fp16', (3,2,1), 32, 2, 2, 1),
        ('fp16', (2,1), 32, 2, 2, 32),
        ('fp16', (1,1,1), 32, 2, 32, 1),
        ('fp16', (3,4,2,1), 32, 32, 32, 1),
    ]

    # Add some randomly generated kernels.
    kernels += [
        ('fp32', (3, 1, 0, 1), 4, 1, 2, 1),
        ('fp16', (9, 0, 2, 2, 1), 2, 2, 2, 8),
        ('fp16', (1, 5, 2, 0, 1), 8, 4, 8, 4),
        ('fp32', (6, 3, 2, 1), 1, 2, 8, 4),
        ('fp32', (1, 4, 1, 1), 16, 4, 4, 2),
        ('fp16', (0, 1), 8, 4, 4, 8),
        ('fp32', (3, 1, 1), 1, 8, 16, 1),
        ('fp32', (1, 5, 6, 0, 1), 2, 4, 8, 2),
        ('fp16', (2, 6, 0, 1), 16, 8, 16, 4),
        ('fp32', (8, 11, 1, 1, 1), 1, 1, 4, 2),
        ('fp16', (4, 6, 0, 1), 4, 8, 32, 2),
        ('fp16', (0, 2, 1), 16, 8, 8, 4),
        ('fp16', (5, 3, 2, 1), 2, 16, 32, 2),
        ('fp16', (2, 3, 1), 4, 2, 8, 2),
        ('fp16', (2, 1, 2, 1), 8, 8, 16, 2)
    ]

    for dtype, subband_counts, W, Dcore, Dout, Tinner in kernels:
        fs = cuda_generator.FrequencySubbands(subband_counts = subband_counts)
        yield cuda_generator.PeakFinder(dtype, fs, W, Dcore, Dout, Tinner)

    if False:
        # For reference, here's the code for randomly generating kernels
        for _ in range(20):
            randi = lambda *args: int(numpy.random.randint(*args))
            nbits = 32 // randi(1,3)
            Dcore = 32 // nbits
            Dout = Dcore
            Tinner = 1

            for _ in range(5):
                n = randi(4)
                if n == 0:
                    Tinner *= 2
                if n == 1:
                    Dcore *= 2
                if 1 <= n <= 2:
                    Dout *= 2
            
            W = 2**randi(5)
            subband_counts = cuda_generator.FrequencySubbands.make_random_subband_counts()
            print(f"('fp{nbits}', {subband_counts}, {W}, {Dcore}, {Dout}, {Tinner})")
    
    
def autogenerated_cdd2_kernels():
    # (dtype, dd_rank, subband_counts, Wmax, Dcore, Dout, Tinner)
    kernels = [ ]

    if production_kernels:
        sc_none = (0,0,0,0,1)    # no subbands
        sc_chime1 = (0,0,1,2,1)  # python -m pirate_frb show_subbands --rank=4 --fmin=400 --fmax=800 --threshold=0.3
        sc_chime2 = (0,5,7,3,1)  # python -m pirate_frb show_subbands --rank=4 --fmin=400 --fmax=800 --threshold=0.1
        sc_chord1 = (1,2,2,2,1)  # python -m pirate_frb show_subbands --rank=4 --fmin=300 --fmax=1500 --threshold=0.4
        sc_chord2 = (5,9,7,3,1)  # python -m pirate_frb show_subbands --rank=4 --fmin=300 --fmax=1500 --threshold=0.1

        Dout = 16
        Dcore = 8
        Tinner = 1

        # FIXME I'd like to use Wmax=32, but that currently fails!
        Wmax = 16

        for dtype in ['fp32','fp16']:
            for dd_rank in [7,8]:
                for subband_counts in [sc_none, sc_chime1, sc_chime2, sc_chord1, sc_chord2]:
                    kernels += [ (dtype, dd_rank, subband_counts, Wmax, Dcore, Dout, Tinner) ]
        
    if debug_cdd2_kernels:
        kernels += [
            ('fp32', 4, (4,0,1), 1, 1, 1, 1)
        ]

    for dtype, dd_rank, subband_counts, W, Dcore, Dout, Tinner in kernels:
        fs = cuda_generator.FrequencySubbands(subband_counts = subband_counts)
        cdd2 = cuda_generator.CoalescedDdKernel2(dtype, dd_rank, fs, W, Dcore, Dout, Tinner)
        yield cdd2

    if False:
        # For reference, here is the code that I ran to generate the above list.
        # FIXME satisfying "temporary restrictions" noted in CoalescedDdKernel2.py
        for _ in range(20):
            randi = lambda *args: int(numpy.random.randint(*args))
            nbits = 32 // randi(1,3)
            dd_rank = randi(3,9)
            pf_rank = dd_rank - (dd_rank // 2)
            subband_counts = cuda_generator.FrequencySubbands.make_random_subband_counts(pf_rank)
            Wmax = 2**randi(5)
            Dcore = 32 // nbits
            Dout = Dcore
            Tinner = 1

            for _ in range(5):
                n = randi(4)
                if n == 0:
                    Tinner *= 2
                if n == 1:
                    Dcore *= 2
                if 1 <= n <= 2:
                    Dout *= 2
            
            print(f"('fp{nbits}', {dd_rank}, {subband_counts}, {Wmax}, {Dcore}, {Dout}, {Tinner})")


def autogenerated_pf_weight_reader_kernels():
    # The parameter space (dtype, subband_counts, Dcore, P, Tinner)
    # is too large to enumerate, so I chose 15 random kernels for testing.
    
    if not debug_pfwr_kernels:
        return
    
    kernels = [
        ('fp32', (2,1,1), 1, 14, 16),
        ('fp16', (7,6,2,1), 8, 10, 2),
        ('fp32', (0,2,1), 1, 1, 4),
        ('fp16', (4,0,1,1), 2, 5, 1),
        ('fp32', (3,2,1), 1, 5, 32),
        ('fp16', (14,4,4,0,1), 8, 3, 2),
        ('fp16', (13,7,3,0,1), 4, 3, 4),
        ('fp16', (3,2,1), 2, 7, 32),
        ('fp32', (6,5,1,1,1), 4, 2, 4),
        ('fp32', (4,3,1,1), 2, 2, 8),
        ('fp32', (3,2,1), 8, 5, 4),
        ('fp16', (1,1,1), 4, 2, 1),
        ('fp32', (9,4,0,2,1), 16, 8, 1),
        ('fp32', (0,2,1), 1, 8, 2),
        ('fp32', (3,0,1), 1, 6, 1)
    ]

    for (dtype, subband_counts, Dcore, P, Tinner) in kernels:
        fs = cuda_generator.FrequencySubbands(subband_counts = subband_counts)
        yield cuda_generator.PfWeightReader(fs, dtype, Dcore, P, Tinner)

    if False:
        # For reference, here is the code that I ran to generate the above list.
        # (I did hand-edit a bit, to avoid gratuitously large source files.)
        for _ in range(15):
            randi = lambda *args: int(numpy.random.randint(*args))
            nbits = 32 // randi(1,3)
            rank = randi(2,5)
            Tinner_log = randi(6)
            Dcore_log = randi(6-Tinner_log) + (32//nbits) - 1
            P = randi(1,15)
            subband_counts = cuda_generator.FrequencySubbands.make_random_subband_counts()
            print(f"('fp{nbits}', {tuple(subband_counts)}, {2**Dcore_log}, {P}, {2**Tinner_log})")
        

def autogenerated_pf_output_kernels():
    # In this case, we can enumerate all valid parameter choices.

    if not debug_pfo_kernels:
        return
    
    for (dtype,Lmin) in [ ('float',0), ('__half',1) ]:
        for L in range(Lmin, 6):
            yield cuda_generator.PfOutput(dtype, Dout=2**L)


####################################################################################################


if __name__ == '__main__':
    main()
#!/usr/bin/env python
#
# This script is invoked by the Makefile, to generate "derived" Makefile variables:
#
#   - PYTHON_INCDIR
#   - NUMPY_INCDIR
#   - PYBIND11_INCDIR
#   - PYEXT_SUFFIX
#   - KSGPU_DIR
#   - AUTOGENERATED_KERNELS
#
# Values of these variables are written to makefile_helper.out.


import io
import os
import sys
import sysconfig
import importlib.util

try:
    import pybind11
except:
    raise RuntimeError("Couldn't import pybind11 -- this is a fatal error")

try:
    import numpy
except:
    raise RuntimeError("Couldn't import numpy -- this is a fatal error")

# This way of getting KSGPU_DIR is awkward, but avoids importing 'ksgpu'.
# (This is useful since imports can generate unexpected output.)
ksgpu_spec = importlib.util.find_spec('ksgpu')
if ksgpu_spec is None:
    raise RuntimeError("Couldn't find 'ksgpu' package -- this is a fatal error")

# This way of importing 'pirate_frb.cuda generator' doesn't assume that the
# larger 'pirate_frb' package has been built or installed.
sys.path.insert(0, 'pirate_frb')
import cuda_generator


####################################################################################################


def main():
    s = io.StringIO()
    print("# Autogenerated by makefile_helper.py (which is automatically invoked by the Makefile)\n", file=s)

    python_incdir = sysconfig.get_config_var('INCLUDEPY')
    print("# Include directory for python headers", file=s)
    print("# From sysconfig.get_config_var('INCLUDEPY')", file=s)
    print(f"PYTHON_INCDIR = {python_incdir}\n", file=s)

    numpy_incdir = numpy.get_include()
    print("# Include directory for numpy headers", file=s)
    print("# From numpy.get_include()", file=s)
    print(f"NUMPY_INCDIR = {numpy_incdir}\n", file=s)

    pybind11_incdir = pybind11.get_include()
    print("# Include directory for pybind11 headers", file=s)
    print("# From pybind11.get_include()", file=s)
    print(f"PYBIND11_INCDIR = {pybind11_incdir}\n", file=s)

    pyext_suffix = sysconfig.get_config_var('EXT_SUFFIX')
    print("# Filename suffix for python extension modules", file=s)
    print("# From sysconfig.get_config_var('EXT_SUFFIX')", file=s)
    print("# Equivalent to 'python3-config --extension-suffix'", file=s)
    print(f"PYEXT_SUFFIX = {pyext_suffix}\n", file=s)

    ksgpu_dir = os.path.dirname(ksgpu_spec.origin)
    print("# Base directory for 'ksgpu' package", file=s)
    print("# From importlib.util.find_spec('ksgpu').origin", file=s)
    print(f"KSGPU_DIR = {ksgpu_dir}\n", file=s)

    print("# CUDA kernels that will be autogenerated (by running ./autogenerate_kernel.py)", file=s)
    print('AUTOGENERATED_KERNELS =', end='', file=s)
    for filename in autogenerated_kernel_filenames():
        print(f' \\\n    {filename}', end='', file=s)
    print(file=s)

    s = s.getvalue()
    outfile = 'makefile_helper.out'
    print(f'Writing {outfile}')

    with open(outfile,'w') as f:
        print(s, file=f, end='')

    # Show summary on stdout (for debugging).
    if False:
        for line in s.split('\n'):
            if (len(line) > 0) and (line[0] != '#'):
                print('   ', line)


####################################################################################################


def autogenerated_kernel_filenames():
    """Top-level generator for autogenerated kernels."""
    
    duplicate_checker = set()
    for basename in autogenerated_kernel_basenames():  # defined below
        if basename not in duplicate_checker:
            duplicate_checker.add(basename)
            yield f'src_lib/autogenerated_kernels/{basename}'


def autogenerated_kernel_basenames():
    for kernel in autogenerated_dedispersion_kernels():
        yield kernel.kernel_basename
    
    for kernel in autogenerated_peak_finding_kernels():
        for basename in kernel.all_kernel_basenames:
            yield basename

    for kernel in autogenerated_cdd2_kernels():
        yield kernel.kernel_basename
    
    for kernel in autogenerated_pf_weight_reader_kernels():
        yield kernel.kernel_basename

    for kernel in autogenerated_pf_output_kernels():
        yield kernel.kernel_basename


def autogenerated_dedispersion_kernels():
    """Generates objects of type 'cuda_generator.MultiDedisperser'."""
    
    for dtype in [ 'float', '__half' ]:
        for (irb,orb) in [ (False,False), (True,False), (False,True) ]:  # see below
            for rlag in [ False, True ]:                                 # see below
                for nspec in [ 1, 8 ]:
                    yield cuda_generator.MultiDedisperser(
                        dtype = dtype,
                        apply_input_residual_lags = rlag,
                        input_is_ringbuf = irb,
                        output_is_ringbuf = orb,
                        nspec = nspec
                    )

        
def autogenerated_peak_finding_kernels():
    # The parameter space (dtype, subband_counts, W, Dcore, Dout, Tinner) is too
    # large to enumerate, so we chooise a few representative kernels.

    # "Corners" of parameter space (16 kernels total)
    # Subband counts here are randomly generated.

    kernels = [
        ('fp32', (1,1), 1, 1, 1, 1),
        ('fp32', (5,5,2,1), 1, 1, 1, 32),
        ('fp32', (0,8,2,2,1), 1, 1, 32, 1),
        ('fp32', (7,0,3,1,1), 1, 32, 32, 1),
        ('fp32', (0,2,0,1), 16, 1, 1, 1),
        ('fp32', (1,1), 16, 1, 1, 32),
        ('fp32', (0,1), 16, 1, 32, 1),
        ('fp32', (2,11,1,0,1), 32, 32, 32, 1),
        ('fp16', (1,1), 1, 2, 2, 1),
        ('fp16', (3,6,5,2,1), 1, 2, 2, 32),
        ('fp16', (2,3,1,1), 1, 2, 32, 1),
        ('fp16', (0,3,2,1), 1, 32, 32, 1),
        ('fp16', (3,2,1), 32, 2, 2, 1),
        ('fp16', (2,1), 32, 2, 2, 32),
        ('fp16', (1,1,1), 32, 2, 32, 1),
        ('fp16', (3,4,2,1), 32, 32, 32, 1),
    ]

    # Add some randomly generated kernels.
    kernels += [
        ('fp32', (3, 1, 0, 1), 4, 1, 2, 1),
        ('fp16', (9, 0, 2, 2, 1), 2, 2, 2, 8),
        ('fp16', (1, 5, 2, 0, 1), 8, 4, 8, 4),
        ('fp32', (6, 3, 2, 1), 1, 2, 8, 4),
        ('fp32', (1, 4, 1, 1), 16, 4, 4, 2),
        ('fp16', (0, 1), 8, 4, 4, 8),
        ('fp32', (3, 1, 1), 1, 8, 16, 1),
        ('fp32', (1, 5, 6, 0, 1), 2, 4, 8, 2),
        ('fp16', (2, 6, 0, 1), 16, 8, 16, 4),
        ('fp32', (8, 11, 1, 1, 1), 1, 1, 4, 2),
        ('fp16', (4, 6, 0, 1), 4, 8, 32, 2),
        ('fp16', (0, 2, 1), 16, 8, 8, 4),
        ('fp16', (5, 3, 2, 1), 2, 16, 32, 2),
        ('fp16', (2, 3, 1), 4, 2, 8, 2),
        ('fp16', (2, 1, 2, 1), 8, 8, 16, 2)
    ]

    for dtype, subband_counts, W, Dcore, Dout, Tinner in kernels:
        fs = cuda_generator.FrequencySubbands(subband_counts = subband_counts)
        yield cuda_generator.PeakFinder(dtype, fs, W, Dcore, Dout, Tinner)

    if False:
        # For reference, here's the code for randomly generating kernels
        for _ in range(100):
            randi = lambda *args: int(numpy.random.randint(*args))
            nbits = 32 // randi(1,3)
            Dcore = 32 // nbits
            Dout = Dcore
            Tinner = 1

            for _ in range(5):
                n = randi(4)
                if n == 0:
                    Tinner *= 2
                if n == 1:
                    Dcore *= 2
                if 1 <= n <= 2:
                    Dout *= 2
            
            W = 2**randi(5)
            subband_counts = cuda_generator.FrequencySubbands.make_random_subband_counts()
            print(f"('fp{nbits}', {subband_counts}, {W}, {Dcore}, {Dout}, {Tinner})")
    
    
def autogenerated_cdd2_kernels():
    # (dtype, dd_rank, frequency_subbands, W, Dcore, Dout, Tinner)
    kernels = [
        ('fp32', 4, (0,0,1), 1, 16, 16, 1),
        ('fp16', 4, (0,0,1), 1, 16, 16, 1)
    ]

    for dtype, dd_rank, subband_counts, W, Dcore, Dout, Tinner in kernels:
        fs = cuda_generator.FrequencySubbands(subband_counts = subband_counts)
        cdd2 = cuda_generator.CoalescedDdKernel2(dtype, dd_rank, fs, W, Dcore, Dout, Tinner)
        yield cdd2


def autogenerated_pf_weight_reader_kernels():
    # The parameter space (dtype, subband_counts, Dcore, P, Tinner)
    # is too large to enumerate, so I chose 15 random kernels for testing.
    
    kernels = [
        ('fp32', (2,1,1), 1, 14, 16),
        ('fp16', (7,6,2,1), 8, 10, 2),
        ('fp32', (0,2,1), 1, 1, 4),
        ('fp16', (4,0,1,1), 2, 5, 1),
        ('fp32', (3,2,1), 1, 5, 32),
        ('fp16', (14,4,4,0,1), 8, 3, 2),
        ('fp16', (13,7,3,0,1), 4, 3, 4),
        ('fp16', (3,2,1), 2, 7, 32),
        ('fp32', (6,5,1,1,1), 4, 2, 4),
        ('fp32', (4,3,1,1), 2, 2, 8),
        ('fp32', (3,2,1), 8, 5, 4),
        ('fp16', (1,1,1), 4, 2, 1),
        ('fp32', (9,4,0,2,1), 16, 8, 1),
        ('fp32', (0,2,1), 1, 8, 2),
        ('fp32', (3,0,1), 1, 6, 1)
    ]

    for (dtype, subband_counts, Dcore, P, Tinner) in kernels:
        fs = cuda_generator.FrequencySubbands(subband_counts = subband_counts)
        yield cuda_generator.PfWeightReader(fs, dtype, Dcore, P, Tinner)

    if False:
        # For reference, here is the code that I ran to generate the above list.
        # (I did hand-edit a bit, to avoid gratuitously large source files.)
        for _ in range(15):
            randi = lambda *args: int(numpy.random.randint(*args))
            nbits = 32 // randi(1,3)
            rank = randi(2,5)
            Tinner_log = randi(6)
            Dcore_log = randi(6-Tinner_log) + (32//nbits) - 1
            P = randi(1,15)
            subband_counts = cuda_generator.FrequencySubbands.make_random_subband_counts()
            print(f"('fp{nbits}', {tuple(subband_counts)}, {2**Dcore_log}, {P}, {2**Tinner_log})")
        

def autogenerated_pf_output_kernels():
    # In this case, we can enumerate all valid parameter choices.
    for (dtype,Lmin) in [ ('float',0), ('__half',1) ]:
        for L in range(Lmin, 6):
            yield cuda_generator.PfOutput(dtype, Dout=2**L)


####################################################################################################


if __name__ == '__main__':
    main()
#!/usr/bin/env python
#
# This script is invoked by the Makefile, to generate "derived" Makefile variables:
#
#   - PYTHON_INCDIR
#   - NUMPY_INCDIR
#   - PYBIND11_INCDIR
#   - PYEXT_SUFFIX
#   - KSGPU_DIR
#   - AUTOGENERATED_KERNELS
#
# Values of these variables are written to makefile_helper.out.


import io
import os
import sys
import sysconfig
import importlib.util

try:
    import pybind11
except:
    raise RuntimeError("Couldn't import pybind11 -- this is a fatal error")

try:
    import numpy
except:
    raise RuntimeError("Couldn't import numpy -- this is a fatal error")

# This way of getting KSGPU_DIR is awkward, but avoids importing 'ksgpu'.
# (This is useful since imports can generate unexpected output.)
ksgpu_spec = importlib.util.find_spec('ksgpu')
if ksgpu_spec is None:
    raise RuntimeError("Couldn't find 'ksgpu' package -- this is a fatal error")

# This way of importing 'pirate_frb.cuda generator' doesn't assume that the
# larger 'pirate_frb' package has been built or installed.
sys.path.insert(0, 'pirate_frb')
import cuda_generator


####################################################################################################


def autogenerated_kernel_filenames():
    """Top-level generator for autogenerated kernels."""
    
    duplicate_checker = set()
    for basename in autogenerated_kernel_basenames():  # defined below
        if basename not in duplicate_checker:
            duplicate_checker.add(basename)
            yield f'src_lib/autogenerated_kernels/{basename}'


def autogenerated_kernel_basenames():
    for kernel in autogenerated_peak_finding_kernels():
        for basename in kernel.all_kernel_basenames:
            yield basename
        
    for params in autogenerated_dedispersion_kernels():
        yield params.filename

    #for params in autogenerated_old_peak_finding_kernels():
    #    yield params.filename
        
    for kernel in autogenerated_pf_weight_reader_kernels():
        yield kernel.test_kernel_basename

    for kernel in autogenerated_pf_output_kernels():
        yield kernel.test_kernel_basename


def autogenerated_dedispersion_kernels():
    """Generates objects of type 'cuda_generator.DedisperserParams'."""
    
    for dtype in [ 'float', '__half' ]:
        for (irb,orb) in [ (False,False), (True,False), (False,True) ]:  # see below
            for rlag in [ False, True ]:                                 # see below
                for nspec in [ 1, 8 ]:
                    yield cuda_generator.DedisperserParams(
                        dtype = dtype,
                        rank = 1,  # dummy value
                        apply_input_residual_lags = rlag,
                        input_is_ringbuf = irb,
                        output_is_ringbuf = orb,
                        nspec = nspec
                    )

        
def autogenerated_old_peak_finding_kernels():
    """Generates objects of type 'cuda_generator.PeakFindingParams'."""
    
    for dtype in [ 'float', '__half' ]:
        # Kernels that we're likely to use in CHIME/CHORD without subbanding.
        for M in [1,2,4,8,16]:
            for E in [ (16//M), (32//M) ]:
                yield cuda_generator.PeakFindingParams(dtype, M=M, E=E, Dout=M)
                
        # "Corners" of parameter space
        for M in [1,32]:
            for E in [1,32]:
                for Dout in [1,32]:
                    if (M, E, Dout) == (32, 32, 1):
                        continue  # This one is problematic -- huge compile time.
                    if (M, E, Dout) == (1, 32, 1):
                        continue  # Already included in "CHIME/CHORD" above.
                    yield cuda_generator.PeakFindingParams(dtype, M, E, Dout)

        # These kernels are timed in src_lib/time_gpu_peak_finding_kernels.cu
        yield cuda_generator.PeakFindingParams(dtype, M=16, E=32, Dout=16)
        yield cuda_generator.PeakFindingParams(dtype, M=50, E=32, Dout=16)

        # Testing these kernels (in addition to those above) should cover
        # all code paths in PfReducer.
        for M in range(1,16):
            yield cuda_generator.PeakFindingParams(dtype, M=M, E=32, Dout=16)


def autogenerated_peak_finding_kernels():
    # The parameter space (dtype, subband_counts, E, Dcore, Dout, Tinner) is too
    # large to enumerate, so we chooise a few representative kernels.

    # "Corners" of parameter space (16 kernels total)
    # Subband counts here are randomly generated.

    kernels = [
        ('fp32', (1,1), 1, 1, 1, 1),
        ('fp32', (5,5,2,1), 1, 1, 1, 32),
        ('fp32', (0,8,2,2,1), 1, 1, 32, 1),
        ('fp32', (7,0,3,1,1), 1, 32, 32, 1),
        ('fp32', (0,2,0,1), 16, 1, 1, 1),
        ('fp32', (1,1), 16, 1, 1, 32),
        ('fp32', (0,1), 16, 1, 32, 1),
        ('fp32', (2,11,1,0,1), 32, 32, 32, 1),
        # ('fp16', xx, xx, 2, 2, 1),
        # ('fp16', xx, xx, 2, 2, 32),
        # ('fp16', xx, xx, 2, 32, 2),
        # ('fp16', xx, xx, 32, 32, 2),
    ]

    # Add a few more randomly generated kernels.
    kernels += [
        ('fp32', (3, 1, 0, 1), 4, 1, 2, 1),
        # ('fp16', (9, 0, 2, 2, 1), 2, 2, 2, 8),
        # ('fp16', (1, 11, 2, 0, 1), 8, 4, 8, 4),
        ('fp32', (6, 3, 2, 1), 1, 2, 8, 4),
        ('fp32', (1, 4, 1, 1), 16, 4, 4, 2),
        # ('fp16', (0, 1), 8, 4, 4, 8),
        ('fp32', (3, 1, 1), 1, 8, 16, 1),
        ('fp32', (1, 5, 6, 0, 1), 2, 4, 8, 2),
        # ('fp16', (2, 6, 0, 1), 16, 8, 16, 4),
        ('fp32', (8, 11, 1, 1, 1), 1, 1, 4, 2),
        # ('fp16', (4, 6, 0, 1), 4, 8, 32, 2)
        # ('fp16', (0, 2, 1), 16, 8, 8, 4)
    ]

    for dtype, subband_counts, E, Dcore, Dout, Tinner in kernels:
        fs = cuda_generator.FrequencySubbands(subband_counts = subband_counts)
        yield cuda_generator.PeakFinder2(dtype, fs, E, Dcore, Dout, Tinner)

    if False:
        # For reference, here's the code for randomly generating kernels
        for _ in range(20):
            randi = lambda *args: int(numpy.random.randint(*args))
            nbits = 32 // randi(1,3)
            Dcore = 32 // nbits
            Dout = Dcore
            Tinner = 1

            for _ in range(5):
                n = randi(4)
                if n == 0:
                    Tinner *= 2
                if n == 1:
                    Dcore *= 2
                if 1 <= n <= 2:
                    Dout *= 2
            
            E = 2**randi(5)
            subband_counts = cuda_generator.FrequencySubbands.make_random_subband_counts()
            print(f"('fp{nbits}', {subband_counts}, {E}, {Dcore}, {Dout}, {Tinner})")
    
    
def autogenerated_pf_weight_reader_kernels():
    # The parameter space (dtype, subband_counts, Dcore, P, Tinner)
    # is too large to enumerate, so I chose 15 random kernels for testing.
    
    kernels = [
        ('fp32', (2,1,1), 1, 14, 16),
        ('fp16', (7,6,2,1), 8, 10, 2),
        ('fp32', (0,2,1), 1, 1, 4),
        ('fp16', (4,0,1,1), 2, 5, 1),
        ('fp32', (3,2,1), 1, 5, 32),
        ('fp16', (14,4,4,0,1), 8, 3, 2),
        ('fp16', (13,7,3,0,1), 4, 3, 4),
        ('fp16', (3,2,1), 2, 7, 32),
        ('fp32', (6,5,1,1,1), 4, 2, 4),
        ('fp32', (4,3,1,1), 2, 2, 8),
        ('fp32', (3,2,1), 8, 5, 4),
        ('fp16', (1,1,1), 4, 2, 1),
        ('fp32', (9,4,0,2,1), 16, 8, 1),
        ('fp32', (0,2,1), 1, 8, 2),
        ('fp32', (3,0,1), 1, 6, 1)
    ]

    for (dtype, subband_counts, Dcore, P, Tinner) in kernels:
        fs = cuda_generator.FrequencySubbands(subband_counts = subband_counts)
        yield cuda_generator.PfWeightReader(fs, dtype, Dcore, P, Tinner)

    if False:
        # For reference, here is the code that I ran to generate the above list.
        # (I did hand-edit a bit, to avoid gratuitously large source files.)
        for _ in range(15):
            randi = lambda *args: int(numpy.random.randint(*args))
            nbits = 32 // randi(1,3)
            rank = randi(2,5)
            Tinner_log = randi(6)
            Dcore_log = randi(6-Tinner_log) + (32//nbits) - 1
            P = randi(1,15)
            subband_counts = cuda_generator.FrequencySubbands.make_random_subband_counts()
            print(f"('fp{nbits}', {tuple(subband_counts)}, {2**Dcore_log}, {P}, {2**Tinner_log})")
        

def autogenerated_pf_output_kernels():
    # In this case, we can enumerate all valid parameter choices.
    for (dtype,Lmin) in [ ('float',0), ('__half',1) ]:
        for L in range(Lmin, 6):
            yield cuda_generator.PfOutput2(dtype, Dout=2**L)


####################################################################################################


s = io.StringIO()
print("# Autogenerated by makefile_helper.py (which is automatically invoked by the Makefile)\n", file=s)

python_incdir = sysconfig.get_config_var('INCLUDEPY')
print("# Include directory for python headers", file=s)
print("# From sysconfig.get_config_var('INCLUDEPY')", file=s)
print(f"PYTHON_INCDIR = {python_incdir}\n", file=s)

numpy_incdir = numpy.get_include()
print("# Include directory for numpy headers", file=s)
print("# From numpy.get_include()", file=s)
print(f"NUMPY_INCDIR = {numpy_incdir}\n", file=s)

pybind11_incdir = pybind11.get_include()
print("# Include directory for pybind11 headers", file=s)
print("# From pybind11.get_include()", file=s)
print(f"PYBIND11_INCDIR = {pybind11_incdir}\n", file=s)

pyext_suffix = sysconfig.get_config_var('EXT_SUFFIX')
print("# Filename suffix for python extension modules", file=s)
print("# From sysconfig.get_config_var('EXT_SUFFIX')", file=s)
print("# Equivalent to 'python3-config --extension-suffix'", file=s)
print(f"PYEXT_SUFFIX = {pyext_suffix}\n", file=s)

ksgpu_dir = os.path.dirname(ksgpu_spec.origin)
print("# Base directory for 'ksgpu' package", file=s)
print("# From importlib.util.find_spec('ksgpu').origin", file=s)
print(f"KSGPU_DIR = {ksgpu_dir}\n", file=s)

print("# CUDA kernels that will be autogenerated (by running ./autogenerate_kernel.py)", file=s)
print('AUTOGENERATED_KERNELS =', end='', file=s)
for filename in autogenerated_kernel_filenames():
    print(f' \\\n    {filename}', end='', file=s)
print(file=s)

s = s.getvalue()
outfile = 'makefile_helper.out'
print(f'Writing {outfile}')

with open(outfile,'w') as f:
    print(s, file=f, end='')

# Show summary on stdout (for debugging).
if False:
    for line in s.split('\n'):
        if (len(line) > 0) and (line[0] != '#'):
            print('   ', line)
